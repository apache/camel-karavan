/**
 * Generated by karavan build tools - do NOT edit this file!
 */
import {
    CamelElement, 
    ProcessorStep, 
    ProcessorStepMeta, 
    FromStep, 
    Expression, 
    PolicyStep, 
    SetPropertyStep, 
    SagaStep, 
    ToDStep, 
    ThreadsStep, 
    InterceptSendToEndpointStep, 
    LogStep, 
    LoopStep, 
    DelayStep, 
    SampleStep, 
    DoFinallyStep, 
    LoadBalanceStep, 
    ValidateStep, 
    TransformStep, 
    RemoveHeadersStep, 
    IdempotentConsumerStep, 
    InterceptStep, 
    When, 
    ProcessStep, 
    OnFallbackStep, 
    MarshalStep, 
    OnCompletionStep, 
    ClaimCheckStep, 
    DoCatchStep, 
    InOnlyStep, 
    ConvertBodyToStep, 
    CircuitBreakerStep, 
    PollEnrichStep, 
    Otherwise, 
    ResequenceStep, 
    RoutingSlipStep, 
    BeanStep, 
    RecipientListStep, 
    KameletStep, 
    DynamicRouterStep, 
    RollbackStep, 
    InOutStep, 
    EnrichStep, 
    SplitStep, 
    WireTapStep, 
    MulticastStep, 
    StopStep, 
    SetBodyStep, 
    SortStep, 
    InterceptFromStep, 
    ThrowExceptionStep, 
    ToStep, 
    FilterStep, 
    ServiceCallStep, 
    ThrottleStep, 
    WhenSkipSendToEndpointStep, 
    RemovePropertiesStep, 
    SetHeaderStep, 
    ChoiceStep, 
    AggregateStep, 
    RemovePropertyStep, 
    RemoveHeaderStep, 
    ScriptStep, 
    DoTryStep, 
    SetExchangePatternStep, 
    TransactedStep, 
    PipelineStep, 
    UnmarshalStep, 
} from '../model/CamelModel' 

export class CamelApi { 

    static capitalizeName = (name: string) => {
        try {
            return name[0].toUpperCase() + name.substring(1);
        } catch (e) {
            return name;
        }
    };

    static camelizeName = (
        name: string,
        separator: string,
        firstSmall: boolean
    ) => {
        const res = name
            .split(separator)
            .map((value) => CamelApi.capitalizeName(value))
            .join("");
        return firstSmall ? res[0].toLowerCase() + res.substring(1) : res;
    };

    static camelizeBody = (name: string, body: any, clone: boolean): any => {
        if (body){
            const oldKey = Object.keys(body)[0];
            const key = CamelApi.camelizeName(oldKey, '-', true);
            return !clone && key === name ? {[key]: body[oldKey]} : body;
        } else {
            return {};
        }
    };

    static createStep = (name: string, body: any, clone: boolean = false): CamelElement => {
       const newBody = CamelApi.camelizeBody(name, body, clone);
       switch (name){
            case 'from': return CamelApi.createFrom(newBody);
            case 'expression': return CamelApi.createExpression(newBody);
            case 'policy': return CamelApi.createPolicy(newBody);
            case 'setProperty': return CamelApi.createSetProperty(newBody);
            case 'saga': return CamelApi.createSaga(newBody);
            case 'toD': return CamelApi.createToD(newBody);
            case 'threads': return CamelApi.createThreads(newBody);
            case 'interceptSendToEndpoint': return CamelApi.createInterceptSendToEndpoint(newBody);
            case 'log': return CamelApi.createLog(newBody);
            case 'loop': return CamelApi.createLoop(newBody);
            case 'delay': return CamelApi.createDelay(newBody);
            case 'sample': return CamelApi.createSample(newBody);
            case 'doFinally': return CamelApi.createDoFinally(newBody);
            case 'loadBalance': return CamelApi.createLoadBalance(newBody);
            case 'validate': return CamelApi.createValidate(newBody);
            case 'transform': return CamelApi.createTransform(newBody);
            case 'removeHeaders': return CamelApi.createRemoveHeaders(newBody);
            case 'idempotentConsumer': return CamelApi.createIdempotentConsumer(newBody);
            case 'intercept': return CamelApi.createIntercept(newBody);
            case 'when': return CamelApi.createWhen(newBody);
            case 'process': return CamelApi.createProcess(newBody);
            case 'onFallback': return CamelApi.createOnFallback(newBody);
            case 'marshal': return CamelApi.createMarshal(newBody);
            case 'onCompletion': return CamelApi.createOnCompletion(newBody);
            case 'claimCheck': return CamelApi.createClaimCheck(newBody);
            case 'doCatch': return CamelApi.createDoCatch(newBody);
            case 'inOnly': return CamelApi.createInOnly(newBody);
            case 'convertBodyTo': return CamelApi.createConvertBodyTo(newBody);
            case 'circuitBreaker': return CamelApi.createCircuitBreaker(newBody);
            case 'pollEnrich': return CamelApi.createPollEnrich(newBody);
            case 'otherwise': return CamelApi.createOtherwise(newBody);
            case 'resequence': return CamelApi.createResequence(newBody);
            case 'routingSlip': return CamelApi.createRoutingSlip(newBody);
            case 'bean': return CamelApi.createBean(newBody);
            case 'recipientList': return CamelApi.createRecipientList(newBody);
            case 'kamelet': return CamelApi.createKamelet(newBody);
            case 'dynamicRouter': return CamelApi.createDynamicRouter(newBody);
            case 'rollback': return CamelApi.createRollback(newBody);
            case 'inOut': return CamelApi.createInOut(newBody);
            case 'enrich': return CamelApi.createEnrich(newBody);
            case 'split': return CamelApi.createSplit(newBody);
            case 'wireTap': return CamelApi.createWireTap(newBody);
            case 'multicast': return CamelApi.createMulticast(newBody);
            case 'stop': return CamelApi.createStop(newBody);
            case 'setBody': return CamelApi.createSetBody(newBody);
            case 'sort': return CamelApi.createSort(newBody);
            case 'interceptFrom': return CamelApi.createInterceptFrom(newBody);
            case 'throwException': return CamelApi.createThrowException(newBody);
            case 'to': return CamelApi.createTo(newBody);
            case 'filter': return CamelApi.createFilter(newBody);
            case 'serviceCall': return CamelApi.createServiceCall(newBody);
            case 'throttle': return CamelApi.createThrottle(newBody);
            case 'whenSkipSendToEndpoint': return CamelApi.createWhenSkipSendToEndpoint(newBody);
            case 'removeProperties': return CamelApi.createRemoveProperties(newBody);
            case 'setHeader': return CamelApi.createSetHeader(newBody);
            case 'choice': return CamelApi.createChoice(newBody);
            case 'aggregate': return CamelApi.createAggregate(newBody);
            case 'removeProperty': return CamelApi.createRemoveProperty(newBody);
            case 'removeHeader': return CamelApi.createRemoveHeader(newBody);
            case 'script': return CamelApi.createScript(newBody);
            case 'doTry': return CamelApi.createDoTry(newBody);
            case 'setExchangePattern': return CamelApi.createSetExchangePattern(newBody);
            case 'transacted': return CamelApi.createTransacted(newBody);
            case 'pipeline': return CamelApi.createPipeline(newBody);
            case 'unmarshal': return CamelApi.createUnmarshal(newBody);
            default: return new ProcessorStep('');
        }
    }
    static createExpression = (element: any): Expression => {
        return new Expression({...element})
    }
    static createFrom = (element: any): FromStep => {
        const fromStep = element ? new FromStep({...element.from}) : new FromStep();
        fromStep.from.steps = CamelApi.createSteps(element?.from?.steps);
        fromStep.uuid = element?.uuid ? element.uuid : fromStep.uuid;
        return fromStep;
    }

    static createPolicy = (element: any): PolicyStep => {
        const policyStep = element ? new PolicyStep({...element.policy}) : new PolicyStep();
        policyStep.policy.steps = CamelApi.createSteps(element?.policy?.steps);
        policyStep.uuid = element?.uuid ? element.uuid : policyStep.uuid;
        return policyStep;
    }

    static createSetProperty = (element: any): SetPropertyStep => {
        const setPropertyStep = element ? new SetPropertyStep({...element.setProperty}) : new SetPropertyStep();
        const implicitExpression = CamelApi.getExpressionLanguage(element.setProperty);
        if (implicitExpression){
            setPropertyStep.setProperty.expression = new Expression({[implicitExpression]: element.setProperty[implicitExpression]});
            delete (setPropertyStep.setProperty as any)[implicitExpression];
        } else {
            setPropertyStep.setProperty.expression = CamelApi.createExpression(element?.setProperty?.expression);
        }
        setPropertyStep.uuid = element?.uuid ? element.uuid : setPropertyStep.uuid;
        return setPropertyStep;
    }

    static createSaga = (element: any): SagaStep => {
        const sagaStep = element ? new SagaStep({...element.saga}) : new SagaStep();
        sagaStep.saga.steps = CamelApi.createSteps(element?.saga?.steps);
        sagaStep.uuid = element?.uuid ? element.uuid : sagaStep.uuid;
        return sagaStep;
    }

    static createToD = (element: any): ToDStep => {
        const toDStep = element ? new ToDStep({...element.toD}) : new ToDStep();
        toDStep.uuid = element?.uuid ? element.uuid : toDStep.uuid;
        return toDStep;
    }

    static createThreads = (element: any): ThreadsStep => {
        const threadsStep = element ? new ThreadsStep({...element.threads}) : new ThreadsStep();
        threadsStep.uuid = element?.uuid ? element.uuid : threadsStep.uuid;
        return threadsStep;
    }

    static createInterceptSendToEndpoint = (element: any): InterceptSendToEndpointStep => {
        const interceptSendToEndpointStep = element ? new InterceptSendToEndpointStep({...element.interceptSendToEndpoint}) : new InterceptSendToEndpointStep();
        interceptSendToEndpointStep.interceptSendToEndpoint.steps = CamelApi.createSteps(element?.interceptSendToEndpoint?.steps);
        interceptSendToEndpointStep.uuid = element?.uuid ? element.uuid : interceptSendToEndpointStep.uuid;
        return interceptSendToEndpointStep;
    }

    static createLog = (element: any): LogStep => {
        const logStep = element ? new LogStep({...element.log}) : new LogStep();
        logStep.uuid = element?.uuid ? element.uuid : logStep.uuid;
        return logStep;
    }

    static createLoop = (element: any): LoopStep => {
        const loopStep = element ? new LoopStep({...element.loop}) : new LoopStep();
        const implicitExpression = CamelApi.getExpressionLanguage(element.loop);
        if (implicitExpression){
            loopStep.loop.expression = new Expression({[implicitExpression]: element.loop[implicitExpression]});
            delete (loopStep.loop as any)[implicitExpression];
        } else {
            loopStep.loop.expression = CamelApi.createExpression(element?.loop?.expression);
        }
        loopStep.loop.steps = CamelApi.createSteps(element?.loop?.steps);
        loopStep.uuid = element?.uuid ? element.uuid : loopStep.uuid;
        return loopStep;
    }

    static createDelay = (element: any): DelayStep => {
        const delayStep = element ? new DelayStep({...element.delay}) : new DelayStep();
        const implicitExpression = CamelApi.getExpressionLanguage(element.delay);
        if (implicitExpression){
            delayStep.delay.expression = new Expression({[implicitExpression]: element.delay[implicitExpression]});
            delete (delayStep.delay as any)[implicitExpression];
        } else {
            delayStep.delay.expression = CamelApi.createExpression(element?.delay?.expression);
        }
        delayStep.uuid = element?.uuid ? element.uuid : delayStep.uuid;
        return delayStep;
    }

    static createSample = (element: any): SampleStep => {
        const sampleStep = element ? new SampleStep({...element.sample}) : new SampleStep();
        sampleStep.uuid = element?.uuid ? element.uuid : sampleStep.uuid;
        return sampleStep;
    }

    static createDoFinally = (element: any): DoFinallyStep => {
        const doFinallyStep = element ? new DoFinallyStep({...element.doFinally}) : new DoFinallyStep();
        doFinallyStep.doFinally.steps = CamelApi.createSteps(element?.doFinally?.steps);
        doFinallyStep.uuid = element?.uuid ? element.uuid : doFinallyStep.uuid;
        return doFinallyStep;
    }

    static createLoadBalance = (element: any): LoadBalanceStep => {
        const loadBalanceStep = element ? new LoadBalanceStep({...element.loadBalance}) : new LoadBalanceStep();
        loadBalanceStep.loadBalance.steps = CamelApi.createSteps(element?.loadBalance?.steps);
        loadBalanceStep.uuid = element?.uuid ? element.uuid : loadBalanceStep.uuid;
        return loadBalanceStep;
    }

    static createValidate = (element: any): ValidateStep => {
        const validateStep = element ? new ValidateStep({...element.validate}) : new ValidateStep();
        const implicitExpression = CamelApi.getExpressionLanguage(element.validate);
        if (implicitExpression){
            validateStep.validate.expression = new Expression({[implicitExpression]: element.validate[implicitExpression]});
            delete (validateStep.validate as any)[implicitExpression];
        } else {
            validateStep.validate.expression = CamelApi.createExpression(element?.validate?.expression);
        }
        validateStep.uuid = element?.uuid ? element.uuid : validateStep.uuid;
        return validateStep;
    }

    static createTransform = (element: any): TransformStep => {
        const transformStep = element ? new TransformStep({...element.transform}) : new TransformStep();
        const implicitExpression = CamelApi.getExpressionLanguage(element.transform);
        if (implicitExpression){
            transformStep.transform.expression = new Expression({[implicitExpression]: element.transform[implicitExpression]});
            delete (transformStep.transform as any)[implicitExpression];
        } else {
            transformStep.transform.expression = CamelApi.createExpression(element?.transform?.expression);
        }
        transformStep.uuid = element?.uuid ? element.uuid : transformStep.uuid;
        return transformStep;
    }

    static createRemoveHeaders = (element: any): RemoveHeadersStep => {
        const removeHeadersStep = element ? new RemoveHeadersStep({...element.removeHeaders}) : new RemoveHeadersStep();
        removeHeadersStep.uuid = element?.uuid ? element.uuid : removeHeadersStep.uuid;
        return removeHeadersStep;
    }

    static createIdempotentConsumer = (element: any): IdempotentConsumerStep => {
        const idempotentConsumerStep = element ? new IdempotentConsumerStep({...element.idempotentConsumer}) : new IdempotentConsumerStep();
        const implicitExpression = CamelApi.getExpressionLanguage(element.idempotentConsumer);
        if (implicitExpression){
            idempotentConsumerStep.idempotentConsumer.expression = new Expression({[implicitExpression]: element.idempotentConsumer[implicitExpression]});
            delete (idempotentConsumerStep.idempotentConsumer as any)[implicitExpression];
        } else {
            idempotentConsumerStep.idempotentConsumer.expression = CamelApi.createExpression(element?.idempotentConsumer?.expression);
        }
        idempotentConsumerStep.idempotentConsumer.steps = CamelApi.createSteps(element?.idempotentConsumer?.steps);
        idempotentConsumerStep.uuid = element?.uuid ? element.uuid : idempotentConsumerStep.uuid;
        return idempotentConsumerStep;
    }

    static createIntercept = (element: any): InterceptStep => {
        const interceptStep = element ? new InterceptStep({...element.intercept}) : new InterceptStep();
        interceptStep.intercept.steps = CamelApi.createSteps(element?.intercept?.steps);
        interceptStep.uuid = element?.uuid ? element.uuid : interceptStep.uuid;
        return interceptStep;
    }

    static createWhen = (element: any): When => {
        const when = element ? new When({...element}) : new When()
        when.expression = CamelApi.createExpression(element?.expression)
        when.steps = CamelApi.createSteps(element?.steps)
        when.uuid = element?.uuid ? element.uuid : when.uuid
        return when
    }

    static createProcess = (element: any): ProcessStep => {
        const processStep = element ? new ProcessStep({...element.process}) : new ProcessStep();
        processStep.uuid = element?.uuid ? element.uuid : processStep.uuid;
        return processStep;
    }

    static createOnFallback = (element: any): OnFallbackStep => {
        const onFallbackStep = element ? new OnFallbackStep({...element.onFallback}) : new OnFallbackStep();
        onFallbackStep.onFallback.steps = CamelApi.createSteps(element?.onFallback?.steps);
        onFallbackStep.uuid = element?.uuid ? element.uuid : onFallbackStep.uuid;
        return onFallbackStep;
    }

    static createMarshal = (element: any): MarshalStep => {
        const marshalStep = element ? new MarshalStep({...element.marshal}) : new MarshalStep();
        marshalStep.uuid = element?.uuid ? element.uuid : marshalStep.uuid;
        return marshalStep;
    }

    static createOnCompletion = (element: any): OnCompletionStep => {
        const onCompletionStep = element ? new OnCompletionStep({...element.onCompletion}) : new OnCompletionStep();
        onCompletionStep.onCompletion.onWhen = CamelApi.createWhen(element?.onCompletion?.onWhen);
        onCompletionStep.onCompletion.steps = CamelApi.createSteps(element?.onCompletion?.steps);
        onCompletionStep.uuid = element?.uuid ? element.uuid : onCompletionStep.uuid;
        return onCompletionStep;
    }

    static createClaimCheck = (element: any): ClaimCheckStep => {
        const claimCheckStep = element ? new ClaimCheckStep({...element.claimCheck}) : new ClaimCheckStep();
        claimCheckStep.uuid = element?.uuid ? element.uuid : claimCheckStep.uuid;
        return claimCheckStep;
    }

    static createDoCatch = (element: any): DoCatchStep => {
        const doCatchStep = element ? new DoCatchStep({...element.doCatch}) : new DoCatchStep();
        doCatchStep.doCatch.onWhen = CamelApi.createWhen(element?.doCatch?.onWhen);
        doCatchStep.doCatch.steps = CamelApi.createSteps(element?.doCatch?.steps);
        doCatchStep.uuid = element?.uuid ? element.uuid : doCatchStep.uuid;
        return doCatchStep;
    }

    static createInOnly = (element: any): InOnlyStep => {
        const inOnlyStep = element ? new InOnlyStep({...element.inOnly}) : new InOnlyStep();
        inOnlyStep.uuid = element?.uuid ? element.uuid : inOnlyStep.uuid;
        return inOnlyStep;
    }

    static createConvertBodyTo = (element: any): ConvertBodyToStep => {
        const convertBodyToStep = element ? new ConvertBodyToStep({...element.convertBodyTo}) : new ConvertBodyToStep();
        convertBodyToStep.uuid = element?.uuid ? element.uuid : convertBodyToStep.uuid;
        return convertBodyToStep;
    }

    static createCircuitBreaker = (element: any): CircuitBreakerStep => {
        const circuitBreakerStep = element ? new CircuitBreakerStep({...element.circuitBreaker}) : new CircuitBreakerStep();
        circuitBreakerStep.circuitBreaker.onFallback = CamelApi.createOnFallback(element?.circuitBreaker?.onFallback);
        circuitBreakerStep.circuitBreaker.steps = CamelApi.createSteps(element?.circuitBreaker?.steps);
        circuitBreakerStep.uuid = element?.uuid ? element.uuid : circuitBreakerStep.uuid;
        return circuitBreakerStep;
    }

    static createPollEnrich = (element: any): PollEnrichStep => {
        const pollEnrichStep = element ? new PollEnrichStep({...element.pollEnrich}) : new PollEnrichStep();
        const implicitExpression = CamelApi.getExpressionLanguage(element.pollEnrich);
        if (implicitExpression){
            pollEnrichStep.pollEnrich.expression = new Expression({[implicitExpression]: element.pollEnrich[implicitExpression]});
            delete (pollEnrichStep.pollEnrich as any)[implicitExpression];
        } else {
            pollEnrichStep.pollEnrich.expression = CamelApi.createExpression(element?.pollEnrich?.expression);
        }
        pollEnrichStep.uuid = element?.uuid ? element.uuid : pollEnrichStep.uuid;
        return pollEnrichStep;
    }

    static createOtherwise = (element: any): Otherwise => {
        const otherwise = element ? new Otherwise({...element}) : new Otherwise();
        otherwise.steps = CamelApi.createSteps(element?.steps);
        if (element?.uuid) otherwise.uuid = element?.uuid;
        return otherwise
    }

    static createResequence = (element: any): ResequenceStep => {
        const resequenceStep = element ? new ResequenceStep({...element.resequence}) : new ResequenceStep();
        const implicitExpression = CamelApi.getExpressionLanguage(element.resequence);
        if (implicitExpression){
            resequenceStep.resequence.expression = new Expression({[implicitExpression]: element.resequence[implicitExpression]});
            delete (resequenceStep.resequence as any)[implicitExpression];
        } else {
            resequenceStep.resequence.expression = CamelApi.createExpression(element?.resequence?.expression);
        }
        resequenceStep.resequence.steps = CamelApi.createSteps(element?.resequence?.steps);
        resequenceStep.uuid = element?.uuid ? element.uuid : resequenceStep.uuid;
        return resequenceStep;
    }

    static createRoutingSlip = (element: any): RoutingSlipStep => {
        const routingSlipStep = element ? new RoutingSlipStep({...element.routingSlip}) : new RoutingSlipStep();
        const implicitExpression = CamelApi.getExpressionLanguage(element.routingSlip);
        if (implicitExpression){
            routingSlipStep.routingSlip.expression = new Expression({[implicitExpression]: element.routingSlip[implicitExpression]});
            delete (routingSlipStep.routingSlip as any)[implicitExpression];
        } else {
            routingSlipStep.routingSlip.expression = CamelApi.createExpression(element?.routingSlip?.expression);
        }
        routingSlipStep.uuid = element?.uuid ? element.uuid : routingSlipStep.uuid;
        return routingSlipStep;
    }

    static createBean = (element: any): BeanStep => {
        const beanStep = element ? new BeanStep({...element.bean}) : new BeanStep();
        beanStep.uuid = element?.uuid ? element.uuid : beanStep.uuid;
        return beanStep;
    }

    static createRecipientList = (element: any): RecipientListStep => {
        const recipientListStep = element ? new RecipientListStep({...element.recipientList}) : new RecipientListStep();
        const implicitExpression = CamelApi.getExpressionLanguage(element.recipientList);
        if (implicitExpression){
            recipientListStep.recipientList.expression = new Expression({[implicitExpression]: element.recipientList[implicitExpression]});
            delete (recipientListStep.recipientList as any)[implicitExpression];
        } else {
            recipientListStep.recipientList.expression = CamelApi.createExpression(element?.recipientList?.expression);
        }
        recipientListStep.uuid = element?.uuid ? element.uuid : recipientListStep.uuid;
        return recipientListStep;
    }

    static createKamelet = (element: any): KameletStep => {
        const kameletStep = element ? new KameletStep({...element.kamelet}) : new KameletStep();
        kameletStep.uuid = element?.uuid ? element.uuid : kameletStep.uuid;
        return kameletStep;
    }

    static createDynamicRouter = (element: any): DynamicRouterStep => {
        const dynamicRouterStep = element ? new DynamicRouterStep({...element.dynamicRouter}) : new DynamicRouterStep();
        const implicitExpression = CamelApi.getExpressionLanguage(element.dynamicRouter);
        if (implicitExpression){
            dynamicRouterStep.dynamicRouter.expression = new Expression({[implicitExpression]: element.dynamicRouter[implicitExpression]});
            delete (dynamicRouterStep.dynamicRouter as any)[implicitExpression];
        } else {
            dynamicRouterStep.dynamicRouter.expression = CamelApi.createExpression(element?.dynamicRouter?.expression);
        }
        dynamicRouterStep.uuid = element?.uuid ? element.uuid : dynamicRouterStep.uuid;
        return dynamicRouterStep;
    }

    static createRollback = (element: any): RollbackStep => {
        const rollbackStep = element ? new RollbackStep({...element.rollback}) : new RollbackStep();
        rollbackStep.uuid = element?.uuid ? element.uuid : rollbackStep.uuid;
        return rollbackStep;
    }

    static createInOut = (element: any): InOutStep => {
        const inOutStep = element ? new InOutStep({...element.inOut}) : new InOutStep();
        inOutStep.uuid = element?.uuid ? element.uuid : inOutStep.uuid;
        return inOutStep;
    }

    static createEnrich = (element: any): EnrichStep => {
        const enrichStep = element ? new EnrichStep({...element.enrich}) : new EnrichStep();
        const implicitExpression = CamelApi.getExpressionLanguage(element.enrich);
        if (implicitExpression){
            enrichStep.enrich.expression = new Expression({[implicitExpression]: element.enrich[implicitExpression]});
            delete (enrichStep.enrich as any)[implicitExpression];
        } else {
            enrichStep.enrich.expression = CamelApi.createExpression(element?.enrich?.expression);
        }
        enrichStep.uuid = element?.uuid ? element.uuid : enrichStep.uuid;
        return enrichStep;
    }

    static createSplit = (element: any): SplitStep => {
        const splitStep = element ? new SplitStep({...element.split}) : new SplitStep();
        const implicitExpression = CamelApi.getExpressionLanguage(element.split);
        if (implicitExpression){
            splitStep.split.expression = new Expression({[implicitExpression]: element.split[implicitExpression]});
            delete (splitStep.split as any)[implicitExpression];
        } else {
            splitStep.split.expression = CamelApi.createExpression(element?.split?.expression);
        }
        splitStep.split.steps = CamelApi.createSteps(element?.split?.steps);
        splitStep.uuid = element?.uuid ? element.uuid : splitStep.uuid;
        return splitStep;
    }

    static createWireTap = (element: any): WireTapStep => {
        const wireTapStep = element ? new WireTapStep({...element.wireTap}) : new WireTapStep();
        wireTapStep.wireTap.body = CamelApi.createExpression(element?.wireTap?.body);
        wireTapStep.wireTap.setHeader = element && element?.wireTap ? element?.wireTap?.setHeader.map((x:any) => CamelApi.createSetHeader(x)) :[];
        wireTapStep.uuid = element?.uuid ? element.uuid : wireTapStep.uuid;
        return wireTapStep;
    }

    static createMulticast = (element: any): MulticastStep => {
        const multicastStep = element ? new MulticastStep({...element.multicast}) : new MulticastStep();
        multicastStep.multicast.steps = CamelApi.createSteps(element?.multicast?.steps);
        multicastStep.uuid = element?.uuid ? element.uuid : multicastStep.uuid;
        return multicastStep;
    }

    static createStop = (element: any): StopStep => {
        const stopStep = element ? new StopStep({...element.stop}) : new StopStep();
        stopStep.uuid = element?.uuid ? element.uuid : stopStep.uuid;
        return stopStep;
    }

    static createSetBody = (element: any): SetBodyStep => {
        const setBodyStep = element ? new SetBodyStep({...element.setBody}) : new SetBodyStep();
        const implicitExpression = CamelApi.getExpressionLanguage(element.setBody);
        if (implicitExpression){
            setBodyStep.setBody.expression = new Expression({[implicitExpression]: element.setBody[implicitExpression]});
            delete (setBodyStep.setBody as any)[implicitExpression];
        } else {
            setBodyStep.setBody.expression = CamelApi.createExpression(element?.setBody?.expression);
        }
        setBodyStep.uuid = element?.uuid ? element.uuid : setBodyStep.uuid;
        return setBodyStep;
    }

    static createSort = (element: any): SortStep => {
        const sortStep = element ? new SortStep({...element.sort}) : new SortStep();
        const implicitExpression = CamelApi.getExpressionLanguage(element.sort);
        if (implicitExpression){
            sortStep.sort.expression = new Expression({[implicitExpression]: element.sort[implicitExpression]});
            delete (sortStep.sort as any)[implicitExpression];
        } else {
            sortStep.sort.expression = CamelApi.createExpression(element?.sort?.expression);
        }
        sortStep.uuid = element?.uuid ? element.uuid : sortStep.uuid;
        return sortStep;
    }

    static createInterceptFrom = (element: any): InterceptFromStep => {
        const interceptFromStep = element ? new InterceptFromStep({...element.interceptFrom}) : new InterceptFromStep();
        interceptFromStep.interceptFrom.steps = CamelApi.createSteps(element?.interceptFrom?.steps);
        interceptFromStep.uuid = element?.uuid ? element.uuid : interceptFromStep.uuid;
        return interceptFromStep;
    }

    static createThrowException = (element: any): ThrowExceptionStep => {
        const throwExceptionStep = element ? new ThrowExceptionStep({...element.throwException}) : new ThrowExceptionStep();
        throwExceptionStep.uuid = element?.uuid ? element.uuid : throwExceptionStep.uuid;
        return throwExceptionStep;
    }

    static createTo = (element: any): ToStep => {
        if (typeof element.to !== 'object') element.to = {uri: element.to};
        const toStep = element ? new ToStep({...element.to}) : new ToStep();
        toStep.uuid = element?.uuid ? element.uuid : toStep.uuid;
        return toStep;
    }

    static createFilter = (element: any): FilterStep => {
        const filterStep = element ? new FilterStep({...element.filter}) : new FilterStep();
        const implicitExpression = CamelApi.getExpressionLanguage(element.filter);
        if (implicitExpression){
            filterStep.filter.expression = new Expression({[implicitExpression]: element.filter[implicitExpression]});
            delete (filterStep.filter as any)[implicitExpression];
        } else {
            filterStep.filter.expression = CamelApi.createExpression(element?.filter?.expression);
        }
        filterStep.filter.steps = CamelApi.createSteps(element?.filter?.steps);
        filterStep.uuid = element?.uuid ? element.uuid : filterStep.uuid;
        return filterStep;
    }

    static createServiceCall = (element: any): ServiceCallStep => {
        const serviceCallStep = element ? new ServiceCallStep({...element.serviceCall}) : new ServiceCallStep();
        serviceCallStep.uuid = element?.uuid ? element.uuid : serviceCallStep.uuid;
        return serviceCallStep;
    }

    static createThrottle = (element: any): ThrottleStep => {
        const throttleStep = element ? new ThrottleStep({...element.throttle}) : new ThrottleStep();
        throttleStep.throttle.correlationExpression = CamelApi.createExpression(element?.throttle?.correlationExpression);
        const implicitExpression = CamelApi.getExpressionLanguage(element.throttle);
        if (implicitExpression){
            throttleStep.throttle.expression = new Expression({[implicitExpression]: element.throttle[implicitExpression]});
            delete (throttleStep.throttle as any)[implicitExpression];
        } else {
            throttleStep.throttle.expression = CamelApi.createExpression(element?.throttle?.expression);
        }
        throttleStep.uuid = element?.uuid ? element.uuid : throttleStep.uuid;
        return throttleStep;
    }

    static createWhenSkipSendToEndpoint = (element: any): WhenSkipSendToEndpointStep => {
        const whenSkipSendToEndpointStep = element ? new WhenSkipSendToEndpointStep({...element.whenSkipSendToEndpoint}) : new WhenSkipSendToEndpointStep();
        const implicitExpression = CamelApi.getExpressionLanguage(element.whenSkipSendToEndpoint);
        if (implicitExpression){
            whenSkipSendToEndpointStep.whenSkipSendToEndpoint.expression = new Expression({[implicitExpression]: element.whenSkipSendToEndpoint[implicitExpression]});
            delete (whenSkipSendToEndpointStep.whenSkipSendToEndpoint as any)[implicitExpression];
        } else {
            whenSkipSendToEndpointStep.whenSkipSendToEndpoint.expression = CamelApi.createExpression(element?.whenSkipSendToEndpoint?.expression);
        }
        whenSkipSendToEndpointStep.whenSkipSendToEndpoint.steps = CamelApi.createSteps(element?.whenSkipSendToEndpoint?.steps);
        whenSkipSendToEndpointStep.uuid = element?.uuid ? element.uuid : whenSkipSendToEndpointStep.uuid;
        return whenSkipSendToEndpointStep;
    }

    static createRemoveProperties = (element: any): RemovePropertiesStep => {
        const removePropertiesStep = element ? new RemovePropertiesStep({...element.removeProperties}) : new RemovePropertiesStep();
        removePropertiesStep.uuid = element?.uuid ? element.uuid : removePropertiesStep.uuid;
        return removePropertiesStep;
    }

    static createSetHeader = (element: any): SetHeaderStep => {
        const setHeaderStep = element ? new SetHeaderStep({...element.setHeader}) : new SetHeaderStep();
        const implicitExpression = CamelApi.getExpressionLanguage(element.setHeader);
        if (implicitExpression){
            setHeaderStep.setHeader.expression = new Expression({[implicitExpression]: element.setHeader[implicitExpression]});
            delete (setHeaderStep.setHeader as any)[implicitExpression];
        } else {
            setHeaderStep.setHeader.expression = CamelApi.createExpression(element?.setHeader?.expression);
        }
        setHeaderStep.uuid = element?.uuid ? element.uuid : setHeaderStep.uuid;
        return setHeaderStep;
    }

    static createChoice = (element: any): ChoiceStep => {
        const choiceStep = element ? new ChoiceStep({...element.choice}) : new ChoiceStep();
        if (element?.choice?.otherwise !== undefined){
            choiceStep.choice.otherwise =  CamelApi.createOtherwise(element?.choice?.otherwise);
        }
        choiceStep.choice.when = element && element?.choice ? element?.choice?.when.map((x:any) => CamelApi.createWhen(x)) :[]
        choiceStep.uuid = element?.uuid ? element.uuid : choiceStep.uuid
        return choiceStep
    }

    static createAggregate = (element: any): AggregateStep => {
        const aggregateStep = element ? new AggregateStep({...element.aggregate}) : new AggregateStep();
        aggregateStep.aggregate.completionPredicate = CamelApi.createExpression(element?.aggregate?.completionPredicate);
        aggregateStep.aggregate.completionSizeExpression = CamelApi.createExpression(element?.aggregate?.completionSizeExpression);
        aggregateStep.aggregate.completionTimeoutExpression = CamelApi.createExpression(element?.aggregate?.completionTimeoutExpression);
        aggregateStep.aggregate.correlationExpression = CamelApi.createExpression(element?.aggregate?.correlationExpression);
        aggregateStep.aggregate.steps = CamelApi.createSteps(element?.aggregate?.steps);
        aggregateStep.uuid = element?.uuid ? element.uuid : aggregateStep.uuid;
        return aggregateStep;
    }

    static createRemoveProperty = (element: any): RemovePropertyStep => {
        const removePropertyStep = element ? new RemovePropertyStep({...element.removeProperty}) : new RemovePropertyStep();
        removePropertyStep.uuid = element?.uuid ? element.uuid : removePropertyStep.uuid;
        return removePropertyStep;
    }

    static createRemoveHeader = (element: any): RemoveHeaderStep => {
        const removeHeaderStep = element ? new RemoveHeaderStep({...element.removeHeader}) : new RemoveHeaderStep();
        removeHeaderStep.uuid = element?.uuid ? element.uuid : removeHeaderStep.uuid;
        return removeHeaderStep;
    }

    static createScript = (element: any): ScriptStep => {
        const scriptStep = element ? new ScriptStep({...element.script}) : new ScriptStep();
        const implicitExpression = CamelApi.getExpressionLanguage(element.script);
        if (implicitExpression){
            scriptStep.script.expression = new Expression({[implicitExpression]: element.script[implicitExpression]});
            delete (scriptStep.script as any)[implicitExpression];
        } else {
            scriptStep.script.expression = CamelApi.createExpression(element?.script?.expression);
        }
        scriptStep.uuid = element?.uuid ? element.uuid : scriptStep.uuid;
        return scriptStep;
    }

    static createDoTry = (element: any): DoTryStep => {
        const doTryStep = element ? new DoTryStep({...element.doTry}) : new DoTryStep();
        doTryStep.doTry.doCatch = element && element?.doTry ? element?.doTry?.doCatch.map((x:any) => CamelApi.createDoCatch(x)) :[];
        doTryStep.doTry.doFinally = CamelApi.createDoFinally(element?.doTry?.doFinally);
        doTryStep.doTry.steps = CamelApi.createSteps(element?.doTry?.steps);
        doTryStep.uuid = element?.uuid ? element.uuid : doTryStep.uuid;
        return doTryStep;
    }

    static createSetExchangePattern = (element: any): SetExchangePatternStep => {
        const setExchangePatternStep = element ? new SetExchangePatternStep({...element.setExchangePattern}) : new SetExchangePatternStep();
        setExchangePatternStep.uuid = element?.uuid ? element.uuid : setExchangePatternStep.uuid;
        return setExchangePatternStep;
    }

    static createTransacted = (element: any): TransactedStep => {
        const transactedStep = element ? new TransactedStep({...element.transacted}) : new TransactedStep();
        transactedStep.transacted.steps = CamelApi.createSteps(element?.transacted?.steps);
        transactedStep.uuid = element?.uuid ? element.uuid : transactedStep.uuid;
        return transactedStep;
    }

    static createPipeline = (element: any): PipelineStep => {
        const pipelineStep = element ? new PipelineStep({...element.pipeline}) : new PipelineStep();
        pipelineStep.pipeline.steps = CamelApi.createSteps(element?.pipeline?.steps);
        pipelineStep.uuid = element?.uuid ? element.uuid : pipelineStep.uuid;
        return pipelineStep;
    }

    static createUnmarshal = (element: any): UnmarshalStep => {
        const unmarshalStep = element ? new UnmarshalStep({...element.unmarshal}) : new UnmarshalStep();
        unmarshalStep.uuid = element?.uuid ? element.uuid : unmarshalStep.uuid;
        return unmarshalStep;
    }

    static createSteps = (elements: any[] | undefined): ProcessorStep[] => {
        const result: ProcessorStep[] = []
        if (elements !== undefined){
            elements.forEach(e => {
                const stepName = Object.keys(e).filter(key => !['uuid', 'dslName'].includes(key))[0];
                result.push(CamelApi.createStep(CamelApi.camelizeName(stepName, '-', true), e));
            })
        }
        return result
    }

    static elementFromStep = (step: CamelElement): CamelElement => {
        switch (step.dslName){
            case 'fromStep' : return (step as FromStep).from
            case 'policyStep': return (step as PolicyStep).policy
            case 'setPropertyStep': return (step as SetPropertyStep).setProperty
            case 'sagaStep': return (step as SagaStep).saga
            case 'toDStep': return (step as ToDStep).toD
            case 'threadsStep': return (step as ThreadsStep).threads
            case 'interceptSendToEndpointStep': return (step as InterceptSendToEndpointStep).interceptSendToEndpoint
            case 'logStep': return (step as LogStep).log
            case 'loopStep': return (step as LoopStep).loop
            case 'delayStep': return (step as DelayStep).delay
            case 'sampleStep': return (step as SampleStep).sample
            case 'doFinallyStep': return (step as DoFinallyStep).doFinally
            case 'loadBalanceStep': return (step as LoadBalanceStep).loadBalance
            case 'validateStep': return (step as ValidateStep).validate
            case 'transformStep': return (step as TransformStep).transform
            case 'removeHeadersStep': return (step as RemoveHeadersStep).removeHeaders
            case 'idempotentConsumerStep': return (step as IdempotentConsumerStep).idempotentConsumer
            case 'interceptStep': return (step as InterceptStep).intercept
            case 'when': return (step as When)
            case 'processStep': return (step as ProcessStep).process
            case 'onFallbackStep': return (step as OnFallbackStep).onFallback
            case 'marshalStep': return (step as MarshalStep).marshal
            case 'onCompletionStep': return (step as OnCompletionStep).onCompletion
            case 'claimCheckStep': return (step as ClaimCheckStep).claimCheck
            case 'doCatchStep': return (step as DoCatchStep).doCatch
            case 'inOnlyStep': return (step as InOnlyStep).inOnly
            case 'convertBodyToStep': return (step as ConvertBodyToStep).convertBodyTo
            case 'circuitBreakerStep': return (step as CircuitBreakerStep).circuitBreaker
            case 'pollEnrichStep': return (step as PollEnrichStep).pollEnrich
            case 'otherwise': return (step as Otherwise)
            case 'resequenceStep': return (step as ResequenceStep).resequence
            case 'routingSlipStep': return (step as RoutingSlipStep).routingSlip
            case 'beanStep': return (step as BeanStep).bean
            case 'recipientListStep': return (step as RecipientListStep).recipientList
            case 'kameletStep': return (step as KameletStep).kamelet
            case 'dynamicRouterStep': return (step as DynamicRouterStep).dynamicRouter
            case 'rollbackStep': return (step as RollbackStep).rollback
            case 'inOutStep': return (step as InOutStep).inOut
            case 'enrichStep': return (step as EnrichStep).enrich
            case 'splitStep': return (step as SplitStep).split
            case 'wireTapStep': return (step as WireTapStep).wireTap
            case 'multicastStep': return (step as MulticastStep).multicast
            case 'stopStep': return (step as StopStep).stop
            case 'setBodyStep': return (step as SetBodyStep).setBody
            case 'sortStep': return (step as SortStep).sort
            case 'interceptFromStep': return (step as InterceptFromStep).interceptFrom
            case 'throwExceptionStep': return (step as ThrowExceptionStep).throwException
            case 'toStep': return (step as ToStep).to
            case 'filterStep': return (step as FilterStep).filter
            case 'serviceCallStep': return (step as ServiceCallStep).serviceCall
            case 'throttleStep': return (step as ThrottleStep).throttle
            case 'whenSkipSendToEndpointStep': return (step as WhenSkipSendToEndpointStep).whenSkipSendToEndpoint
            case 'removePropertiesStep': return (step as RemovePropertiesStep).removeProperties
            case 'setHeaderStep': return (step as SetHeaderStep).setHeader
            case 'choiceStep': return (step as ChoiceStep).choice
            case 'aggregateStep': return (step as AggregateStep).aggregate
            case 'removePropertyStep': return (step as RemovePropertyStep).removeProperty
            case 'removeHeaderStep': return (step as RemoveHeaderStep).removeHeader
            case 'scriptStep': return (step as ScriptStep).script
            case 'doTryStep': return (step as DoTryStep).doTry
            case 'setExchangePatternStep': return (step as SetExchangePatternStep).setExchangePattern
            case 'transactedStep': return (step as TransactedStep).transacted
            case 'pipelineStep': return (step as PipelineStep).pipeline
            case 'unmarshalStep': return (step as UnmarshalStep).unmarshal
            default : return new CamelElement('')
        }
    }

    static addStep = (steps: ProcessorStep[], step: ProcessorStep, parentId: string, position?: number): ProcessorStep[] => {
        const result: ProcessorStep[] = [];
        steps.forEach(el => {
            switch (el.dslName) {
                case 'policyStep':
                    const policyChildren = (el as PolicyStep).policy?.steps || [];
                    if (el.uuid === parentId) position !== undefined ? policyChildren.splice(position, 0, step) : policyChildren.push(step);
                    else (el as PolicyStep).policy.steps = CamelApi.addStep(policyChildren, step, parentId, position);
                    break;
                case 'choiceStep':
                    const choiceChildren = (el as ChoiceStep).choice?.when || [];
                    if (el.uuid === parentId && step.dslName === 'when') {
                        choiceChildren.push(step as When);
                        (el as ChoiceStep).choice.when = choiceChildren;
                    }  else if (el.uuid === parentId && step.dslName === 'otherwise' && !(el as ChoiceStep).choice.otherwise) {
                        (el as ChoiceStep).choice.otherwise = step;
                    } else {
                        (el as ChoiceStep).choice.when = CamelApi.addStep(choiceChildren, step, parentId, position) as When[];
                        const otherwise = (el as ChoiceStep).choice.otherwise;
                        if (otherwise?.uuid === parentId){
                            otherwise.steps = otherwise.steps ? [...otherwise.steps] : [];
                            otherwise.steps.push(step);
                            (el as ChoiceStep).choice.otherwise = otherwise
                        } else if (otherwise && otherwise.steps && otherwise.steps.length > 0){
                            otherwise.steps = CamelApi.addStep(otherwise.steps, step, parentId, position);
                            (el as ChoiceStep).choice.otherwise = otherwise;
                        }
                    }
                    break;
                case 'otherwise':
                    const otherwiseChildren = (el as Otherwise).steps || [];
                    if (el.uuid === parentId) position !== undefined ? otherwiseChildren.splice(position, 0, step) : otherwiseChildren.push(step);
                    else (el as Otherwise).steps = CamelApi.addStep(otherwiseChildren, step, parentId, position);
                    break;
                case 'fromStep':
                    const fromChildren = (el as FromStep).from?.steps || [];
                    if (el.uuid === parentId) position !== undefined ? fromChildren.splice(position, 0, step) : fromChildren.push(step);
                    else (el as FromStep).from.steps = CamelApi.addStep(fromChildren, step, parentId, position);
                    break;
                case 'onCompletionStep':
                    const onCompletionChildren = (el as OnCompletionStep).onCompletion?.steps || [];
                    if (el.uuid === parentId) position !== undefined ? onCompletionChildren.splice(position, 0, step) : onCompletionChildren.push(step);
                    else (el as OnCompletionStep).onCompletion.steps = CamelApi.addStep(onCompletionChildren, step, parentId, position);
                    break;
                case 'splitStep':
                    const splitChildren = (el as SplitStep).split?.steps || [];
                    if (el.uuid === parentId) position !== undefined ? splitChildren.splice(position, 0, step) : splitChildren.push(step);
                    else (el as SplitStep).split.steps = CamelApi.addStep(splitChildren, step, parentId, position);
                    break;
                case 'transactedStep':
                    const transactedChildren = (el as TransactedStep).transacted?.steps || [];
                    if (el.uuid === parentId) position !== undefined ? transactedChildren.splice(position, 0, step) : transactedChildren.push(step);
                    else (el as TransactedStep).transacted.steps = CamelApi.addStep(transactedChildren, step, parentId, position);
                    break;
                case 'interceptFromStep':
                    const interceptFromChildren = (el as InterceptFromStep).interceptFrom?.steps || [];
                    if (el.uuid === parentId) position !== undefined ? interceptFromChildren.splice(position, 0, step) : interceptFromChildren.push(step);
                    else (el as InterceptFromStep).interceptFrom.steps = CamelApi.addStep(interceptFromChildren, step, parentId, position);
                    break;
                case 'doCatchStep':
                    const doCatchChildren = (el as DoCatchStep).doCatch?.steps || [];
                    if (el.uuid === parentId) position !== undefined ? doCatchChildren.splice(position, 0, step) : doCatchChildren.push(step);
                    else (el as DoCatchStep).doCatch.steps = CamelApi.addStep(doCatchChildren, step, parentId, position);
                    break;
                case 'circuitBreakerStep':
                    const circuitBreakerChildren = (el as CircuitBreakerStep).circuitBreaker?.steps || [];
                    if (el.uuid === parentId) position !== undefined ? circuitBreakerChildren.splice(position, 0, step) : circuitBreakerChildren.push(step);
                    else (el as CircuitBreakerStep).circuitBreaker.steps = CamelApi.addStep(circuitBreakerChildren, step, parentId, position);
                    break;
                case 'interceptStep':
                    const interceptChildren = (el as InterceptStep).intercept?.steps || [];
                    if (el.uuid === parentId) position !== undefined ? interceptChildren.splice(position, 0, step) : interceptChildren.push(step);
                    else (el as InterceptStep).intercept.steps = CamelApi.addStep(interceptChildren, step, parentId, position);
                    break;
                case 'onFallbackStep':
                    const onFallbackChildren = (el as OnFallbackStep).onFallback?.steps || [];
                    if (el.uuid === parentId) position !== undefined ? onFallbackChildren.splice(position, 0, step) : onFallbackChildren.push(step);
                    else (el as OnFallbackStep).onFallback.steps = CamelApi.addStep(onFallbackChildren, step, parentId, position);
                    break;
                case 'multicastStep':
                    const multicastChildren = (el as MulticastStep).multicast?.steps || [];
                    if (el.uuid === parentId) position !== undefined ? multicastChildren.splice(position, 0, step) : multicastChildren.push(step);
                    else (el as MulticastStep).multicast.steps = CamelApi.addStep(multicastChildren, step, parentId, position);
                    break;
                case 'loadBalanceStep':
                    const loadBalanceChildren = (el as LoadBalanceStep).loadBalance?.steps || [];
                    if (el.uuid === parentId) position !== undefined ? loadBalanceChildren.splice(position, 0, step) : loadBalanceChildren.push(step);
                    else (el as LoadBalanceStep).loadBalance.steps = CamelApi.addStep(loadBalanceChildren, step, parentId, position);
                    break;
                case 'whenSkipSendToEndpointStep':
                    const whenSkipSendToEndpointChildren = (el as WhenSkipSendToEndpointStep).whenSkipSendToEndpoint?.steps || [];
                    if (el.uuid === parentId) position !== undefined ? whenSkipSendToEndpointChildren.splice(position, 0, step) : whenSkipSendToEndpointChildren.push(step);
                    else (el as WhenSkipSendToEndpointStep).whenSkipSendToEndpoint.steps = CamelApi.addStep(whenSkipSendToEndpointChildren, step, parentId, position);
                    break;
                case 'loopStep':
                    const loopChildren = (el as LoopStep).loop?.steps || [];
                    if (el.uuid === parentId) position !== undefined ? loopChildren.splice(position, 0, step) : loopChildren.push(step);
                    else (el as LoopStep).loop.steps = CamelApi.addStep(loopChildren, step, parentId, position);
                    break;
                case 'interceptSendToEndpointStep':
                    const interceptSendToEndpointChildren = (el as InterceptSendToEndpointStep).interceptSendToEndpoint?.steps || [];
                    if (el.uuid === parentId) position !== undefined ? interceptSendToEndpointChildren.splice(position, 0, step) : interceptSendToEndpointChildren.push(step);
                    else (el as InterceptSendToEndpointStep).interceptSendToEndpoint.steps = CamelApi.addStep(interceptSendToEndpointChildren, step, parentId, position);
                    break;
                case 'doTryStep':
                    const doTryChildren = (el as DoTryStep).doTry?.steps || [];
                    if (el.uuid === parentId) position !== undefined ? doTryChildren.splice(position, 0, step) : doTryChildren.push(step);
                    else (el as DoTryStep).doTry.steps = CamelApi.addStep(doTryChildren, step, parentId, position);
                    break;
                case 'resequenceStep':
                    const resequenceChildren = (el as ResequenceStep).resequence?.steps || [];
                    if (el.uuid === parentId) position !== undefined ? resequenceChildren.splice(position, 0, step) : resequenceChildren.push(step);
                    else (el as ResequenceStep).resequence.steps = CamelApi.addStep(resequenceChildren, step, parentId, position);
                    break;
                case 'pipelineStep':
                    const pipelineChildren = (el as PipelineStep).pipeline?.steps || [];
                    if (el.uuid === parentId) position !== undefined ? pipelineChildren.splice(position, 0, step) : pipelineChildren.push(step);
                    else (el as PipelineStep).pipeline.steps = CamelApi.addStep(pipelineChildren, step, parentId, position);
                    break;
                case 'sagaStep':
                    const sagaChildren = (el as SagaStep).saga?.steps || [];
                    if (el.uuid === parentId) position !== undefined ? sagaChildren.splice(position, 0, step) : sagaChildren.push(step);
                    else (el as SagaStep).saga.steps = CamelApi.addStep(sagaChildren, step, parentId, position);
                    break;
                case 'when':
                    const whenChildren = (el as When).steps || [];
                    if (el.uuid === parentId) position !== undefined ? whenChildren.splice(position, 0, step) : whenChildren.push(step);
                    else (el as When).steps = CamelApi.addStep(whenChildren, step, parentId, position);
                    break;
                case 'doFinallyStep':
                    const doFinallyChildren = (el as DoFinallyStep).doFinally?.steps || [];
                    if (el.uuid === parentId) position !== undefined ? doFinallyChildren.splice(position, 0, step) : doFinallyChildren.push(step);
                    else (el as DoFinallyStep).doFinally.steps = CamelApi.addStep(doFinallyChildren, step, parentId, position);
                    break;
                case 'filterStep':
                    const filterChildren = (el as FilterStep).filter?.steps || [];
                    if (el.uuid === parentId) position !== undefined ? filterChildren.splice(position, 0, step) : filterChildren.push(step);
                    else (el as FilterStep).filter.steps = CamelApi.addStep(filterChildren, step, parentId, position);
                    break;
                case 'aggregateStep':
                    const aggregateChildren = (el as AggregateStep).aggregate?.steps || [];
                    if (el.uuid === parentId) position !== undefined ? aggregateChildren.splice(position, 0, step) : aggregateChildren.push(step);
                    else (el as AggregateStep).aggregate.steps = CamelApi.addStep(aggregateChildren, step, parentId, position);
                    break;
                case 'idempotentConsumerStep':
                    const idempotentConsumerChildren = (el as IdempotentConsumerStep).idempotentConsumer?.steps || [];
                    if (el.uuid === parentId) position !== undefined ? idempotentConsumerChildren.splice(position, 0, step) : idempotentConsumerChildren.push(step);
                    else (el as IdempotentConsumerStep).idempotentConsumer.steps = CamelApi.addStep(idempotentConsumerChildren, step, parentId, position);
                    break;
            }
            result.push(el);
        })
        return result;
    }

    static deleteStep = (steps: ProcessorStep[] | undefined, uuidToDelete: string): ProcessorStep[] => {
        const result: ProcessorStep[] = []
        if (steps !== undefined){
            steps.forEach(step => {
                if (step.uuid !== uuidToDelete){
                    switch (step.dslName){
                        case 'policyStep': (step as PolicyStep).policy.steps = CamelApi.deleteStep((step as PolicyStep).policy.steps, uuidToDelete); break;
                        case 'choiceStep':
                            const otherwise = (step as ChoiceStep).choice.otherwise;
                            if (otherwise && otherwise.uuid === uuidToDelete) {
                                (step as ChoiceStep).choice.otherwise = undefined;
                            } else if (otherwise && otherwise.uuid !== uuidToDelete) {
                                otherwise.steps = CamelApi.deleteStep(otherwise.steps, uuidToDelete);
                                (step as ChoiceStep).choice.otherwise = otherwise;
                            }
                            (step as ChoiceStep).choice.when = CamelApi.deleteWhen((step as ChoiceStep).choice.when, uuidToDelete);
                            break;
                        case 'otherwise': (step as Otherwise).steps = CamelApi.deleteStep((step as Otherwise).steps, uuidToDelete); break;
                        case 'fromStep': (step as FromStep).from.steps = CamelApi.deleteStep((step as FromStep).from.steps, uuidToDelete); break;
                        case 'onCompletionStep': (step as OnCompletionStep).onCompletion.steps = CamelApi.deleteStep((step as OnCompletionStep).onCompletion.steps, uuidToDelete); break;
                        case 'splitStep': (step as SplitStep).split.steps = CamelApi.deleteStep((step as SplitStep).split.steps, uuidToDelete); break;
                        case 'transactedStep': (step as TransactedStep).transacted.steps = CamelApi.deleteStep((step as TransactedStep).transacted.steps, uuidToDelete); break;
                        case 'interceptFromStep': (step as InterceptFromStep).interceptFrom.steps = CamelApi.deleteStep((step as InterceptFromStep).interceptFrom.steps, uuidToDelete); break;
                        case 'doCatchStep': (step as DoCatchStep).doCatch.steps = CamelApi.deleteStep((step as DoCatchStep).doCatch.steps, uuidToDelete); break;
                        case 'circuitBreakerStep': (step as CircuitBreakerStep).circuitBreaker.steps = CamelApi.deleteStep((step as CircuitBreakerStep).circuitBreaker.steps, uuidToDelete); break;
                        case 'interceptStep': (step as InterceptStep).intercept.steps = CamelApi.deleteStep((step as InterceptStep).intercept.steps, uuidToDelete); break;
                        case 'onFallbackStep': (step as OnFallbackStep).onFallback.steps = CamelApi.deleteStep((step as OnFallbackStep).onFallback.steps, uuidToDelete); break;
                        case 'multicastStep': (step as MulticastStep).multicast.steps = CamelApi.deleteStep((step as MulticastStep).multicast.steps, uuidToDelete); break;
                        case 'loadBalanceStep': (step as LoadBalanceStep).loadBalance.steps = CamelApi.deleteStep((step as LoadBalanceStep).loadBalance.steps, uuidToDelete); break;
                        case 'whenSkipSendToEndpointStep': (step as WhenSkipSendToEndpointStep).whenSkipSendToEndpoint.steps = CamelApi.deleteStep((step as WhenSkipSendToEndpointStep).whenSkipSendToEndpoint.steps, uuidToDelete); break;
                        case 'loopStep': (step as LoopStep).loop.steps = CamelApi.deleteStep((step as LoopStep).loop.steps, uuidToDelete); break;
                        case 'interceptSendToEndpointStep': (step as InterceptSendToEndpointStep).interceptSendToEndpoint.steps = CamelApi.deleteStep((step as InterceptSendToEndpointStep).interceptSendToEndpoint.steps, uuidToDelete); break;
                        case 'doTryStep': (step as DoTryStep).doTry.steps = CamelApi.deleteStep((step as DoTryStep).doTry.steps, uuidToDelete); break;
                        case 'resequenceStep': (step as ResequenceStep).resequence.steps = CamelApi.deleteStep((step as ResequenceStep).resequence.steps, uuidToDelete); break;
                        case 'pipelineStep': (step as PipelineStep).pipeline.steps = CamelApi.deleteStep((step as PipelineStep).pipeline.steps, uuidToDelete); break;
                        case 'sagaStep': (step as SagaStep).saga.steps = CamelApi.deleteStep((step as SagaStep).saga.steps, uuidToDelete); break;
                        case 'when': (step as When).steps = CamelApi.deleteStep((step as When).steps, uuidToDelete); break;
                        case 'doFinallyStep': (step as DoFinallyStep).doFinally.steps = CamelApi.deleteStep((step as DoFinallyStep).doFinally.steps, uuidToDelete); break;
                        case 'filterStep': (step as FilterStep).filter.steps = CamelApi.deleteStep((step as FilterStep).filter.steps, uuidToDelete); break;
                        case 'aggregateStep': (step as AggregateStep).aggregate.steps = CamelApi.deleteStep((step as AggregateStep).aggregate.steps, uuidToDelete); break;
                        case 'idempotentConsumerStep': (step as IdempotentConsumerStep).idempotentConsumer.steps = CamelApi.deleteStep((step as IdempotentConsumerStep).idempotentConsumer.steps, uuidToDelete); break;
                    }
                    result.push(step);
                }
            })
        }
        return result
    }

    static deleteWhen = (whens: When[] | undefined, uuidToDelete: string): When[] => {
        const result: When[] = []
        if (whens !== undefined){
            whens.forEach(when => {
                if (when.uuid !== uuidToDelete) {
                    when.steps = CamelApi.deleteStep(when.steps, uuidToDelete);
                    result.push(when);
                }
            })
        }
        return result
    }

    static findStep = (steps: ProcessorStep[] | undefined, uuid: string, parentUuid?: string, result?: ProcessorStepMeta): ProcessorStepMeta => {
        if (result?.step !== undefined) return result;
        if (result === undefined) result = new ProcessorStepMeta(undefined, parentUuid, undefined, []);
        if (steps !== undefined){
            for (let index = 0, step; step = steps[index]; index++) {
                if (step.uuid !== uuid) {
                    switch (step.dslName) {
                        case 'policyStep':
                            result = CamelApi.findStep((step as PolicyStep).policy.steps, uuid, step.uuid, result);
                            if (result?.pathUuids !== undefined && result?.pathUuids.length > 0) result.pathUuids.push(step.uuid);
                            break;
                        case 'choiceStep':
                            const o = (step as ChoiceStep).choice.otherwise;
                            const w = (step as ChoiceStep).choice.when;
                            const s: ProcessorStep[] = [];
                            if (o) s.push(o);
                            if (w) s.push(...w);
                            result = CamelApi.findStep(s, uuid, step.uuid, result);
                            if (result?.pathUuids !== undefined && result?.pathUuids.length > 0) result.pathUuids.push(step.uuid);
                            break;
                        case 'otherwise':
                            result = CamelApi.findStep((step as Otherwise).steps, uuid, step.uuid, result);
                            if (result?.pathUuids !== undefined && result?.pathUuids.length > 0) result.pathUuids.push(step.uuid);
                            break;
                        case 'fromStep':
                            result = CamelApi.findStep((step as FromStep).from.steps, uuid, step.uuid, result);
                            if (result?.pathUuids !== undefined && result?.pathUuids.length > 0) result.pathUuids.push(step.uuid);
                            break;
                        case 'onCompletionStep':
                            result = CamelApi.findStep((step as OnCompletionStep).onCompletion.steps, uuid, step.uuid, result);
                            if (result?.pathUuids !== undefined && result?.pathUuids.length > 0) result.pathUuids.push(step.uuid);
                            break;
                        case 'splitStep':
                            result = CamelApi.findStep((step as SplitStep).split.steps, uuid, step.uuid, result);
                            if (result?.pathUuids !== undefined && result?.pathUuids.length > 0) result.pathUuids.push(step.uuid);
                            break;
                        case 'transactedStep':
                            result = CamelApi.findStep((step as TransactedStep).transacted.steps, uuid, step.uuid, result);
                            if (result?.pathUuids !== undefined && result?.pathUuids.length > 0) result.pathUuids.push(step.uuid);
                            break;
                        case 'interceptFromStep':
                            result = CamelApi.findStep((step as InterceptFromStep).interceptFrom.steps, uuid, step.uuid, result);
                            if (result?.pathUuids !== undefined && result?.pathUuids.length > 0) result.pathUuids.push(step.uuid);
                            break;
                        case 'doCatchStep':
                            result = CamelApi.findStep((step as DoCatchStep).doCatch.steps, uuid, step.uuid, result);
                            if (result?.pathUuids !== undefined && result?.pathUuids.length > 0) result.pathUuids.push(step.uuid);
                            break;
                        case 'circuitBreakerStep':
                            result = CamelApi.findStep((step as CircuitBreakerStep).circuitBreaker.steps, uuid, step.uuid, result);
                            if (result?.pathUuids !== undefined && result?.pathUuids.length > 0) result.pathUuids.push(step.uuid);
                            break;
                        case 'interceptStep':
                            result = CamelApi.findStep((step as InterceptStep).intercept.steps, uuid, step.uuid, result);
                            if (result?.pathUuids !== undefined && result?.pathUuids.length > 0) result.pathUuids.push(step.uuid);
                            break;
                        case 'onFallbackStep':
                            result = CamelApi.findStep((step as OnFallbackStep).onFallback.steps, uuid, step.uuid, result);
                            if (result?.pathUuids !== undefined && result?.pathUuids.length > 0) result.pathUuids.push(step.uuid);
                            break;
                        case 'multicastStep':
                            result = CamelApi.findStep((step as MulticastStep).multicast.steps, uuid, step.uuid, result);
                            if (result?.pathUuids !== undefined && result?.pathUuids.length > 0) result.pathUuids.push(step.uuid);
                            break;
                        case 'loadBalanceStep':
                            result = CamelApi.findStep((step as LoadBalanceStep).loadBalance.steps, uuid, step.uuid, result);
                            if (result?.pathUuids !== undefined && result?.pathUuids.length > 0) result.pathUuids.push(step.uuid);
                            break;
                        case 'whenSkipSendToEndpointStep':
                            result = CamelApi.findStep((step as WhenSkipSendToEndpointStep).whenSkipSendToEndpoint.steps, uuid, step.uuid, result);
                            if (result?.pathUuids !== undefined && result?.pathUuids.length > 0) result.pathUuids.push(step.uuid);
                            break;
                        case 'loopStep':
                            result = CamelApi.findStep((step as LoopStep).loop.steps, uuid, step.uuid, result);
                            if (result?.pathUuids !== undefined && result?.pathUuids.length > 0) result.pathUuids.push(step.uuid);
                            break;
                        case 'interceptSendToEndpointStep':
                            result = CamelApi.findStep((step as InterceptSendToEndpointStep).interceptSendToEndpoint.steps, uuid, step.uuid, result);
                            if (result?.pathUuids !== undefined && result?.pathUuids.length > 0) result.pathUuids.push(step.uuid);
                            break;
                        case 'doTryStep':
                            result = CamelApi.findStep((step as DoTryStep).doTry.steps, uuid, step.uuid, result);
                            if (result?.pathUuids !== undefined && result?.pathUuids.length > 0) result.pathUuids.push(step.uuid);
                            break;
                        case 'resequenceStep':
                            result = CamelApi.findStep((step as ResequenceStep).resequence.steps, uuid, step.uuid, result);
                            if (result?.pathUuids !== undefined && result?.pathUuids.length > 0) result.pathUuids.push(step.uuid);
                            break;
                        case 'pipelineStep':
                            result = CamelApi.findStep((step as PipelineStep).pipeline.steps, uuid, step.uuid, result);
                            if (result?.pathUuids !== undefined && result?.pathUuids.length > 0) result.pathUuids.push(step.uuid);
                            break;
                        case 'sagaStep':
                            result = CamelApi.findStep((step as SagaStep).saga.steps, uuid, step.uuid, result);
                            if (result?.pathUuids !== undefined && result?.pathUuids.length > 0) result.pathUuids.push(step.uuid);
                            break;
                        case 'when':
                            result = CamelApi.findStep((step as When).steps, uuid, step.uuid, result);
                            if (result?.pathUuids !== undefined && result?.pathUuids.length > 0) result.pathUuids.push(step.uuid);
                            break;
                        case 'doFinallyStep':
                            result = CamelApi.findStep((step as DoFinallyStep).doFinally.steps, uuid, step.uuid, result);
                            if (result?.pathUuids !== undefined && result?.pathUuids.length > 0) result.pathUuids.push(step.uuid);
                            break;
                        case 'filterStep':
                            result = CamelApi.findStep((step as FilterStep).filter.steps, uuid, step.uuid, result);
                            if (result?.pathUuids !== undefined && result?.pathUuids.length > 0) result.pathUuids.push(step.uuid);
                            break;
                        case 'aggregateStep':
                            result = CamelApi.findStep((step as AggregateStep).aggregate.steps, uuid, step.uuid, result);
                            if (result?.pathUuids !== undefined && result?.pathUuids.length > 0) result.pathUuids.push(step.uuid);
                            break;
                        case 'idempotentConsumerStep':
                            result = CamelApi.findStep((step as IdempotentConsumerStep).idempotentConsumer.steps, uuid, step.uuid, result);
                            if (result?.pathUuids !== undefined && result?.pathUuids.length > 0) result.pathUuids.push(step.uuid);
                            break;
                    }
                } else {
                    const paths: string[] = result?.pathUuids ? result?.pathUuids : [];
                    paths.push(step.uuid);
                    result = new  ProcessorStepMeta(step, parentUuid, index, paths);
                    break;
                }
            }
        }
        const paths: string[] = result?.pathUuids ? result?.pathUuids : [];
        return new ProcessorStepMeta(result?.step, result?.parentUuid, result?.position, result?.pathUuids);
    }

    static getExpressionLanguage = (init?: Partial<Expression>): string | undefined => {
        if (init?.constant) return 'constant'
        if (init?.csimple) return 'csimple'
        if (init?.datasonnet) return 'datasonnet'
        if (init?.exchangeProperty) return 'exchangeProperty'
        if (init?.groovy) return 'groovy'
        if (init?.header) return 'header'
        if (init?.hl7terser) return 'hl7terser'
        if (init?.joor) return 'joor'
        if (init?.jsonpath) return 'jsonpath'
        if (init?.method) return 'method'
        if (init?.mvel) return 'mvel'
        if (init?.ognl) return 'ognl'
        if (init?.ref) return 'ref'
        if (init?.simple) return 'simple'
        if (init?.spel) return 'spel'
        if (init?.tokenize) return 'tokenize'
        if (init?.xpath) return 'xpath'
        if (init?.xquery) return 'xquery'
        if (init?.xtokenize) return 'xtokenize'
        return undefined;
    }
}

