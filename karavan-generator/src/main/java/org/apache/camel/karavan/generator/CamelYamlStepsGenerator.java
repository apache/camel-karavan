/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.karavan.generator;

import java.io.BufferedReader;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.util.*;
import java.util.stream.Collectors;

public final class CamelYamlStepsGenerator extends AbstractGenerator {

    public String generate(Map<String, List<ElementProp>> models, Map<String, String> processors, Map<String, String> propertyToMapStrings){
        StringBuilder camelApi = new StringBuilder();
        camelApi.append(
                "/**\n" +
                        " * Generated by karavan build tools - do NOT edit this file!\n" +
                        " */\n");
        camelApi.append("import {\n");
        camelApi.append("    CamelElement, \n");
        camelApi.append("    From, \n");
        camelApi.append("    Expression, \n");
        processors.values().forEach(s -> {
            if (s.equalsIgnoreCase("otherwise")) {
                camelApi.append("    Otherwise, \n");
            } else if (s.equalsIgnoreCase("when")) {
                camelApi.append("    When, \n");
            } else {
                camelApi.append("    ").append(s).append(",\n");
            }
        });
        camelApi.append("} from '../model/CamelModel' \n");
        camelApi.append("import * as dataFormat from '../model/CamelDataFormat'; \n");
        camelApi.append("import {CamelUtil} from \"./CamelUtil\";  \n\n");

        camelApi.append("export class CamelYamlStep { \n\n");

        camelApi.append(
                "    static readStep = (name: string, body: any, clone: boolean = false): CamelElement => {\n" +
                        "       const newBody = CamelUtil.camelizeBody(name, body, clone);\n" +
                        "       switch (name){\n" +
                        "            case 'from': return CamelYamlStep.readFrom(newBody);\n" +
                        "            case 'expression': return CamelYamlStep.readExpression(newBody);\n");
        processors.values().forEach(s ->
                camelApi.append("            case '").append(deCapitalize(s)).append("': return CamelYamlStep.read").append(capitalize(s)).append("(newBody);\n"));
        camelApi.append("            default: return new CamelElement('');\n");
        camelApi.append("        }\n");
        camelApi.append("    }\n");


        camelApi.append(
                "    static readExpression = (element: any): Expression => {\n" +
                        "        return new Expression({...element})\n" +
                        "    }\n");
        camelApi.append(createCreateFunction("from", models.get("from"), "uri"));

        processors.values().forEach((model) -> camelApi.append(createCreateFunction(model, models.get(model), propertyToMapStrings.get(model))));


        camelApi.append(
                "    static readSteps = (elements: any[] | undefined): CamelElement[] => {\n" +
                        "        const result: CamelElement[] = []\n" +
                        "        if (elements !== undefined){\n" +
                        "            elements.forEach(e => {\n" +
                        "                const stepName = Object.keys(e).filter(key => !['uuid', 'dslName'].includes(key))[0];\n" +
                        "                result.push(CamelYamlStep.readStep(CamelUtil.camelizeName(stepName, '-', true), e));\n" +
                        "            })\n" +
                        "        }\n" +
                        "        return result\n" +
                        "    }\n\n");


        // Expression language finder
        camelApi.append("    static readExpressionLanguage = (init?: Partial<Expression>): string | undefined => {\n");
        models.get("expression").forEach(el -> {
            if (!el.name.equals("language"))
                camelApi.append(String.format("        if (init?.%s) return '%s'\n", el.name, el.name));
        });
        camelApi.append("        return undefined;\n");
        camelApi.append("    }\n");

        camelApi.append("}\n").append(System.lineSeparator());

        return camelApi.toString();
    }

    private String createCreateFunction(String name, List<ElementProp> elProps, String propertyToMapStrings) {
        if (name.equalsIgnoreCase("otherwise")) {
            return getTemplateFile("CamelYamlStep.readOtherwise.tx").concat("\n\n");
        } else if (name.equalsIgnoreCase("when")) {
            return getTemplateFile("CamelYamlStep.readWhen.tx").concat("\n\n");
        } else if (name.equalsIgnoreCase("choice")) {
            return getTemplateFile("CamelYamlStep.readChoice.tx").concat("\n\n");
        }
        String stepClass = capitalize(name);
        String stepField = deCapitalize(name);
        String elementName = deCapitalize(name);
        String funcName = "read".concat(capitalize(name));
        StringBuilder f = new StringBuilder();
        f.append(String.format("    static %s = (element: any): %s => {\n", funcName, stepClass));
        if (stepClass.equals("To") || stepClass.equals("Tod")) {
            f.append(String.format("        if (typeof element.%1$s !== 'object') element.%1$s = {uri: element.%1$s};\n", elementName));
        }
        // for oneOf string or object Definitions
        if (propertyToMapStrings != null){
            String p = deCapitalize(camelize(propertyToMapStrings, "-"));
            f.append(String.format("        if (element && element.%1$s && typeof element.%1$s === 'string') element.%1$s = {%2$s: element.%1$s};\n", elementName, p));
        }
        f.append(String.format("        const %1$s = element ? new %2$s({...element.%3$s}) : new %2$s();\n", stepField, stepClass, elementName));
        elProps.stream().forEach(e -> {
            if (e.name.equals("steps")) {
                f.append(String.format("        %1$s.steps = CamelYamlStep.readSteps(element?.%2$s?.steps);\n", stepField, elementName));
            } else if (e.isArray && e.isArrayTypeClass) {
                f.append(String.format("        %1$s.%3$s = element && element?.%2$s ? element?.%2$s?.%3$s.map((x:any) => CamelYamlStep.read%4$s(x)) :[];\n", stepField, elementName, e.name, e.arrayType));
            } else if (e.name.equalsIgnoreCase("expression")) {
                f.append(String.format("        const implicitExpression = CamelYamlStep.readExpressionLanguage(element.%s);\n", elementName));
                f.append(String.format("        if (implicitExpression){\n"));
                f.append(String.format("            %1$s.expression = new Expression({[implicitExpression]: element.%2$s[implicitExpression]});\n", stepField, elementName));
                f.append(String.format("            delete (%1$s as any)[implicitExpression];\n", stepField));
                f.append(String.format("        } else {\n"));
                f.append(String.format("            %1$s.expression = CamelYamlStep.readExpression(element?.%2$s?.expression);\n", stepField, elementName));
                f.append(String.format("        }\n"));
            } else if (e.typeCode.startsWith("dataFormat.")) {
                String temp = "        if (element.%3$s?.%1$s !== undefined) %2$s.%1$s = new %4$s(element.%3$s.%1$s);\n";
                f.append(String.format(temp, e.name, stepField, elementName, e.typeCode));
            } else if (e.isObject) {
                f.append(String.format("        %s.%s = CamelYamlStep.read%s(element?.%s?.%s);\n", stepField, e.name, e.type, elementName, e.name));
            }
        });
        f.append(String.format("        %s.uuid = element?.uuid ? element.uuid : %s.uuid;\n", stepField, stepField));
        f.append(String.format("        return %s;\n", stepField));
        f.append("    }\n\n");
        return f.toString();
    }


    public String getTemplateFile(String name) {
        try {
            InputStream inputStream = CamelYamlStepsGenerator.class.getClassLoader().getResourceAsStream(name);
            String data = new BufferedReader(new InputStreamReader(inputStream))
                    .lines().collect(Collectors.joining(System.getProperty("line.separator")));
            return data;
        } catch (Exception e) {
            return null;
        }
    }
}
