/**
 * Generated by karavan build tools - do NOT edit this file!
 */
import {
    CamelElement, 
    CamelElementMeta, 
    From, 
    Expression, 
    Policy,
    SetProperty,
    Saga,
    ToD,
    Threads,
    InterceptSendToEndpoint,
    Log,
    Loop,
    Delay,
    Sample,
    DoFinally,
    LoadBalance,
    Validate,
    Transform,
    RemoveHeaders,
    IdempotentConsumer,
    Intercept,
    When, 
    Process,
    OnFallback,
    Marshal,
    OnCompletion,
    ClaimCheck,
    DoCatch,
    InOnly,
    ConvertBodyTo,
    CircuitBreaker,
    PollEnrich,
    Otherwise, 
    Resequence,
    RoutingSlip,
    Bean,
    RecipientList,
    Kamelet,
    DynamicRouter,
    Rollback,
    InOut,
    Enrich,
    Split,
    WireTap,
    Multicast,
    Stop,
    SetBody,
    Sort,
    InterceptFrom,
    ThrowException,
    To,
    Filter,
    ServiceCall,
    Throttle,
    WhenSkipSendToEndpoint,
    RemoveProperties,
    SetHeader,
    Choice,
    Aggregate,
    RemoveProperty,
    RemoveHeader,
    Script,
    DoTry,
    SetExchangePattern,
    Transacted,
    Pipeline,
    Unmarshal,
} from '../model/CamelModel' 
import * as dataFormat from '../model/CamelDataFormat'; 
import {CamelUtil} from "./CamelUtil";  

export class CamelApi { 

    static createStep = (name: string, body: any, clone: boolean = false): CamelElement => {
       const newBody = CamelUtil.camelizeBody(name, body, clone);
       switch (name){
            case 'from': return CamelApi.createFrom(newBody);
            case 'expression': return CamelApi.createExpression(newBody);
            case 'policy': return CamelApi.createPolicy(newBody);
            case 'setProperty': return CamelApi.createSetProperty(newBody);
            case 'saga': return CamelApi.createSaga(newBody);
            case 'toD': return CamelApi.createToD(newBody);
            case 'threads': return CamelApi.createThreads(newBody);
            case 'interceptSendToEndpoint': return CamelApi.createInterceptSendToEndpoint(newBody);
            case 'log': return CamelApi.createLog(newBody);
            case 'loop': return CamelApi.createLoop(newBody);
            case 'delay': return CamelApi.createDelay(newBody);
            case 'sample': return CamelApi.createSample(newBody);
            case 'doFinally': return CamelApi.createDoFinally(newBody);
            case 'loadBalance': return CamelApi.createLoadBalance(newBody);
            case 'validate': return CamelApi.createValidate(newBody);
            case 'transform': return CamelApi.createTransform(newBody);
            case 'removeHeaders': return CamelApi.createRemoveHeaders(newBody);
            case 'idempotentConsumer': return CamelApi.createIdempotentConsumer(newBody);
            case 'intercept': return CamelApi.createIntercept(newBody);
            case 'when': return CamelApi.createWhen(newBody);
            case 'process': return CamelApi.createProcess(newBody);
            case 'onFallback': return CamelApi.createOnFallback(newBody);
            case 'marshal': return CamelApi.createMarshal(newBody);
            case 'onCompletion': return CamelApi.createOnCompletion(newBody);
            case 'claimCheck': return CamelApi.createClaimCheck(newBody);
            case 'doCatch': return CamelApi.createDoCatch(newBody);
            case 'inOnly': return CamelApi.createInOnly(newBody);
            case 'convertBodyTo': return CamelApi.createConvertBodyTo(newBody);
            case 'circuitBreaker': return CamelApi.createCircuitBreaker(newBody);
            case 'pollEnrich': return CamelApi.createPollEnrich(newBody);
            case 'otherwise': return CamelApi.createOtherwise(newBody);
            case 'resequence': return CamelApi.createResequence(newBody);
            case 'routingSlip': return CamelApi.createRoutingSlip(newBody);
            case 'bean': return CamelApi.createBean(newBody);
            case 'recipientList': return CamelApi.createRecipientList(newBody);
            case 'kamelet': return CamelApi.createKamelet(newBody);
            case 'dynamicRouter': return CamelApi.createDynamicRouter(newBody);
            case 'rollback': return CamelApi.createRollback(newBody);
            case 'inOut': return CamelApi.createInOut(newBody);
            case 'enrich': return CamelApi.createEnrich(newBody);
            case 'split': return CamelApi.createSplit(newBody);
            case 'wireTap': return CamelApi.createWireTap(newBody);
            case 'multicast': return CamelApi.createMulticast(newBody);
            case 'stop': return CamelApi.createStop(newBody);
            case 'setBody': return CamelApi.createSetBody(newBody);
            case 'sort': return CamelApi.createSort(newBody);
            case 'interceptFrom': return CamelApi.createInterceptFrom(newBody);
            case 'throwException': return CamelApi.createThrowException(newBody);
            case 'to': return CamelApi.createTo(newBody);
            case 'filter': return CamelApi.createFilter(newBody);
            case 'serviceCall': return CamelApi.createServiceCall(newBody);
            case 'throttle': return CamelApi.createThrottle(newBody);
            case 'whenSkipSendToEndpoint': return CamelApi.createWhenSkipSendToEndpoint(newBody);
            case 'removeProperties': return CamelApi.createRemoveProperties(newBody);
            case 'setHeader': return CamelApi.createSetHeader(newBody);
            case 'choice': return CamelApi.createChoice(newBody);
            case 'aggregate': return CamelApi.createAggregate(newBody);
            case 'removeProperty': return CamelApi.createRemoveProperty(newBody);
            case 'removeHeader': return CamelApi.createRemoveHeader(newBody);
            case 'script': return CamelApi.createScript(newBody);
            case 'doTry': return CamelApi.createDoTry(newBody);
            case 'setExchangePattern': return CamelApi.createSetExchangePattern(newBody);
            case 'transacted': return CamelApi.createTransacted(newBody);
            case 'pipeline': return CamelApi.createPipeline(newBody);
            case 'unmarshal': return CamelApi.createUnmarshal(newBody);
            default: return new CamelElement('');
        }
    }
    static createExpression = (element: any): Expression => {
        return new Expression({...element})
    }
    static createFrom = (element: any): From => {
        if (element && typeof element === 'string') element = {uri: element};
        const from = element ? new From({...element}) : new From();
        from.steps = CamelApi.createSteps(element?.steps);
        from.uuid = element?.uuid ? element.uuid : from.uuid;
        return from;
    }

    static createPolicy = (element: any): Policy => {
        const policy = element ? new Policy({...element}) : new Policy();
        policy.steps = CamelApi.createSteps(element?.steps);
        policy.uuid = element?.uuid ? element.uuid : policy.uuid;
        return policy;
    }

    static createSetProperty = (element: any): SetProperty => {
        const setProperty = element ? new SetProperty({...element}) : new SetProperty();
        const implicitExpression = CamelApi.getExpressionLanguage(element);
        if (implicitExpression){
            setProperty.expression = new Expression({[implicitExpression]: element[implicitExpression]});
            delete (setProperty as any)[implicitExpression];
        } else {
            setProperty.expression = CamelApi.createExpression(element?.expression);
        }
        setProperty.uuid = element?.uuid ? element.uuid : setProperty.uuid;
        return setProperty;
    }

    static createSaga = (element: any): Saga => {
        const saga = element ? new Saga({...element}) : new Saga();
        saga.steps = CamelApi.createSteps(element?.steps);
        saga.uuid = element?.uuid ? element.uuid : saga.uuid;
        return saga;
    }

    static createToD = (element: any): ToD => {
        if (element && typeof element === 'string') element = {uri: element};
        const toD = element ? new ToD({...element}) : new ToD();
        toD.uuid = element?.uuid ? element.uuid : toD.uuid;
        return toD;
    }

    static createThreads = (element: any): Threads => {
        const threads = element ? new Threads({...element}) : new Threads();
        threads.uuid = element?.uuid ? element.uuid : threads.uuid;
        return threads;
    }

    static createInterceptSendToEndpoint = (element: any): InterceptSendToEndpoint => {
        if (element && typeof element === 'string') element = {uri: element};
        const interceptSendToEndpoint = element ? new InterceptSendToEndpoint({...element}) : new InterceptSendToEndpoint();
        interceptSendToEndpoint.steps = CamelApi.createSteps(element?.steps);
        interceptSendToEndpoint.uuid = element?.uuid ? element.uuid : interceptSendToEndpoint.uuid;
        return interceptSendToEndpoint;
    }

    static createLog = (element: any): Log => {
        if (element && typeof element === 'string') element = {message: element};
        const log = element ? new Log({...element}) : new Log();
        log.uuid = element?.uuid ? element.uuid : log.uuid;
        return log;
    }

    static createLoop = (element: any): Loop => {
        const loop = element ? new Loop({...element}) : new Loop();
        const implicitExpression = CamelApi.getExpressionLanguage(element);
        if (implicitExpression){
            loop.expression = new Expression({[implicitExpression]: element[implicitExpression]});
            delete (loop as any)[implicitExpression];
        } else {
            loop.expression = CamelApi.createExpression(element?.expression);
        }
        loop.steps = CamelApi.createSteps(element?.steps);
        loop.uuid = element?.uuid ? element.uuid : loop.uuid;
        return loop;
    }

    static createDelay = (element: any): Delay => {
        const delay = element ? new Delay({...element}) : new Delay();
        const implicitExpression = CamelApi.getExpressionLanguage(element);
        if (implicitExpression){
            delay.expression = new Expression({[implicitExpression]: element[implicitExpression]});
            delete (delay as any)[implicitExpression];
        } else {
            delay.expression = CamelApi.createExpression(element?.expression);
        }
        delay.uuid = element?.uuid ? element.uuid : delay.uuid;
        return delay;
    }

    static createSample = (element: any): Sample => {
        const sample = element ? new Sample({...element}) : new Sample();
        sample.uuid = element?.uuid ? element.uuid : sample.uuid;
        return sample;
    }

    static createDoFinally = (element: any): DoFinally => {
        const doFinally = element ? new DoFinally({...element}) : new DoFinally();
        doFinally.steps = CamelApi.createSteps(element?.steps);
        doFinally.uuid = element?.uuid ? element.uuid : doFinally.uuid;
        return doFinally;
    }

    static createLoadBalance = (element: any): LoadBalance => {
        const loadBalance = element ? new LoadBalance({...element}) : new LoadBalance();
        loadBalance.steps = CamelApi.createSteps(element?.steps);
        loadBalance.uuid = element?.uuid ? element.uuid : loadBalance.uuid;
        return loadBalance;
    }

    static createValidate = (element: any): Validate => {
        const validate = element ? new Validate({...element}) : new Validate();
        const implicitExpression = CamelApi.getExpressionLanguage(element);
        if (implicitExpression){
            validate.expression = new Expression({[implicitExpression]: element[implicitExpression]});
            delete (validate as any)[implicitExpression];
        } else {
            validate.expression = CamelApi.createExpression(element?.expression);
        }
        validate.uuid = element?.uuid ? element.uuid : validate.uuid;
        return validate;
    }

    static createTransform = (element: any): Transform => {
        const transform = element ? new Transform({...element}) : new Transform();
        const implicitExpression = CamelApi.getExpressionLanguage(element);
        if (implicitExpression){
            transform.expression = new Expression({[implicitExpression]: element[implicitExpression]});
            delete (transform as any)[implicitExpression];
        } else {
            transform.expression = CamelApi.createExpression(element?.expression);
        }
        transform.uuid = element?.uuid ? element.uuid : transform.uuid;
        return transform;
    }

    static createRemoveHeaders = (element: any): RemoveHeaders => {
        if (element && typeof element === 'string') element = {pattern: element};
        const removeHeaders = element ? new RemoveHeaders({...element}) : new RemoveHeaders();
        removeHeaders.uuid = element?.uuid ? element.uuid : removeHeaders.uuid;
        return removeHeaders;
    }

    static createIdempotentConsumer = (element: any): IdempotentConsumer => {
        const idempotentConsumer = element ? new IdempotentConsumer({...element}) : new IdempotentConsumer();
        const implicitExpression = CamelApi.getExpressionLanguage(element);
        if (implicitExpression){
            idempotentConsumer.expression = new Expression({[implicitExpression]: element[implicitExpression]});
            delete (idempotentConsumer as any)[implicitExpression];
        } else {
            idempotentConsumer.expression = CamelApi.createExpression(element?.expression);
        }
        idempotentConsumer.steps = CamelApi.createSteps(element?.steps);
        idempotentConsumer.uuid = element?.uuid ? element.uuid : idempotentConsumer.uuid;
        return idempotentConsumer;
    }

    static createIntercept = (element: any): Intercept => {
        const intercept = element ? new Intercept({...element}) : new Intercept();
        intercept.steps = CamelApi.createSteps(element?.steps);
        intercept.uuid = element?.uuid ? element.uuid : intercept.uuid;
        return intercept;
    }

    static createWhen = (element: any): When => {
        const when = element ? new When({...element}) : new When()
        when.expression = CamelApi.createExpression(element?.expression)
        when.steps = CamelApi.createSteps(element?.steps)
        when.uuid = element?.uuid ? element.uuid : when.uuid
        return when
    }

    static createProcess = (element: any): Process => {
        const process = element ? new Process({...element}) : new Process();
        process.uuid = element?.uuid ? element.uuid : process.uuid;
        return process;
    }

    static createOnFallback = (element: any): OnFallback => {
        const onFallback = element ? new OnFallback({...element}) : new OnFallback();
        onFallback.steps = CamelApi.createSteps(element?.steps);
        onFallback.uuid = element?.uuid ? element.uuid : onFallback.uuid;
        return onFallback;
    }

    static createMarshal = (element: any): Marshal => {
        const marshal = element ? new Marshal({...element}) : new Marshal();
        if (element.any23 !== undefined) marshal.any23 = new dataFormat.Any23DataFormat(element.any23);
        if (element.asn1 !== undefined) marshal.asn1 = new dataFormat.ASN1DataFormat(element.asn1);
        if (element.avro !== undefined) marshal.avro = new dataFormat.AvroDataFormat(element.avro);
        if (element.barcode !== undefined) marshal.barcode = new dataFormat.BarcodeDataFormat(element.barcode);
        if (element.base64 !== undefined) marshal.base64 = new dataFormat.Base64DataFormat(element.base64);
        if (element.beanio !== undefined) marshal.beanio = new dataFormat.BeanioDataFormat(element.beanio);
        if (element.bindy !== undefined) marshal.bindy = new dataFormat.BindyDataFormat(element.bindy);
        if (element.cbor !== undefined) marshal.cbor = new dataFormat.CBORDataFormat(element.cbor);
        if (element.crypto !== undefined) marshal.crypto = new dataFormat.CryptoDataFormat(element.crypto);
        if (element.csv !== undefined) marshal.csv = new dataFormat.CsvDataFormat(element.csv);
        if (element.custom !== undefined) marshal.custom = new dataFormat.CustomDataFormat(element.custom);
        if (element.fhirJson !== undefined) marshal.fhirJson = new dataFormat.FhirJsonDataFormat(element.fhirJson);
        if (element.fhirXml !== undefined) marshal.fhirXml = new dataFormat.FhirXmlDataFormat(element.fhirXml);
        if (element.flatpack !== undefined) marshal.flatpack = new dataFormat.FlatpackDataFormat(element.flatpack);
        if (element.grok !== undefined) marshal.grok = new dataFormat.GrokDataFormat(element.grok);
        if (element.gzip !== undefined) marshal.gzip = new dataFormat.GzipDataFormat(element.gzip);
        if (element.hl7 !== undefined) marshal.hl7 = new dataFormat.HL7DataFormat(element.hl7);
        if (element.ical !== undefined) marshal.ical = new dataFormat.IcalDataFormat(element.ical);
        if (element.jacksonxml !== undefined) marshal.jacksonxml = new dataFormat.JacksonXMLDataFormat(element.jacksonxml);
        if (element.jaxb !== undefined) marshal.jaxb = new dataFormat.JaxbDataFormat(element.jaxb);
        if (element.json !== undefined) marshal.json = new dataFormat.JsonDataFormat(element.json);
        if (element.jsonApi !== undefined) marshal.jsonApi = new dataFormat.JsonApiDataFormat(element.jsonApi);
        if (element.lzf !== undefined) marshal.lzf = new dataFormat.LZFDataFormat(element.lzf);
        if (element.mimeMultipart !== undefined) marshal.mimeMultipart = new dataFormat.MimeMultipartDataFormat(element.mimeMultipart);
        if (element.pgp !== undefined) marshal.pgp = new dataFormat.PGPDataFormat(element.pgp);
        if (element.protobuf !== undefined) marshal.protobuf = new dataFormat.ProtobufDataFormat(element.protobuf);
        if (element.rss !== undefined) marshal.rss = new dataFormat.RssDataFormat(element.rss);
        if (element.secureXml !== undefined) marshal.secureXml = new dataFormat.XMLSecurityDataFormat(element.secureXml);
        if (element.soapjaxb !== undefined) marshal.soapjaxb = new dataFormat.SoapJaxbDataFormat(element.soapjaxb);
        if (element.syslog !== undefined) marshal.syslog = new dataFormat.SyslogDataFormat(element.syslog);
        if (element.tarfile !== undefined) marshal.tarfile = new dataFormat.TarFileDataFormat(element.tarfile);
        if (element.thrift !== undefined) marshal.thrift = new dataFormat.ThriftDataFormat(element.thrift);
        if (element.tidyMarkup !== undefined) marshal.tidyMarkup = new dataFormat.TidyMarkupDataFormat(element.tidyMarkup);
        if (element.univocityCsv !== undefined) marshal.univocityCsv = new dataFormat.UniVocityCsvDataFormat(element.univocityCsv);
        if (element.univocityFixed !== undefined) marshal.univocityFixed = new dataFormat.UniVocityFixedWidthDataFormat(element.univocityFixed);
        if (element.univocityTsv !== undefined) marshal.univocityTsv = new dataFormat.UniVocityTsvDataFormat(element.univocityTsv);
        if (element.xmlrpc !== undefined) marshal.xmlrpc = new dataFormat.XmlRpcDataFormat(element.xmlrpc);
        if (element.xstream !== undefined) marshal.xstream = new dataFormat.XStreamDataFormat(element.xstream);
        if (element.yaml !== undefined) marshal.yaml = new dataFormat.YAMLDataFormat(element.yaml);
        if (element.zip !== undefined) marshal.zip = new dataFormat.ZipDeflaterDataFormat(element.zip);
        if (element.zipfile !== undefined) marshal.zipfile = new dataFormat.ZipFileDataFormat(element.zipfile);
        marshal.uuid = element?.uuid ? element.uuid : marshal.uuid;
        return marshal;
    }

    static createOnCompletion = (element: any): OnCompletion => {
        const onCompletion = element ? new OnCompletion({...element}) : new OnCompletion();
        onCompletion.onWhen = CamelApi.createWhen(element?.onCompletion?.onWhen);
        onCompletion.steps = CamelApi.createSteps(element?.steps);
        onCompletion.uuid = element?.uuid ? element.uuid : onCompletion.uuid;
        return onCompletion;
    }

    static createClaimCheck = (element: any): ClaimCheck => {
        const claimCheck = element ? new ClaimCheck({...element}) : new ClaimCheck();
        claimCheck.uuid = element?.uuid ? element.uuid : claimCheck.uuid;
        return claimCheck;
    }

    static createDoCatch = (element: any): DoCatch => {
        const doCatch = element ? new DoCatch({...element}) : new DoCatch();
        doCatch.onWhen = CamelApi.createWhen(element?.doCatch?.onWhen);
        doCatch.steps = CamelApi.createSteps(element?.steps);
        doCatch.uuid = element?.uuid ? element.uuid : doCatch.uuid;
        return doCatch;
    }

    static createInOnly = (element: any): InOnly => {
        if (element && typeof element === 'string') element = {uri: element};
        const inOnly = element ? new InOnly({...element}) : new InOnly();
        inOnly.uuid = element?.uuid ? element.uuid : inOnly.uuid;
        return inOnly;
    }

    static createConvertBodyTo = (element: any): ConvertBodyTo => {
        if (element && typeof element === 'string') element = {type: element};
        const convertBodyTo = element ? new ConvertBodyTo({...element}) : new ConvertBodyTo();
        convertBodyTo.uuid = element?.uuid ? element.uuid : convertBodyTo.uuid;
        return convertBodyTo;
    }

    static createCircuitBreaker = (element: any): CircuitBreaker => {
        const circuitBreaker = element ? new CircuitBreaker({...element}) : new CircuitBreaker();
        circuitBreaker.onFallback = CamelApi.createOnFallback(element?.circuitBreaker?.onFallback);
        circuitBreaker.steps = CamelApi.createSteps(element?.steps);
        circuitBreaker.uuid = element?.uuid ? element.uuid : circuitBreaker.uuid;
        return circuitBreaker;
    }

    static createPollEnrich = (element: any): PollEnrich => {
        const pollEnrich = element ? new PollEnrich({...element}) : new PollEnrich();
        const implicitExpression = CamelApi.getExpressionLanguage(element);
        if (implicitExpression){
            pollEnrich.expression = new Expression({[implicitExpression]: element[implicitExpression]});
            delete (pollEnrich as any)[implicitExpression];
        } else {
            pollEnrich.expression = CamelApi.createExpression(element?.expression);
        }
        pollEnrich.uuid = element?.uuid ? element.uuid : pollEnrich.uuid;
        return pollEnrich;
    }

    static createOtherwise = (element: any): Otherwise => {
        const otherwise = element ? new Otherwise({...element}) : new Otherwise();
        otherwise.steps = CamelApi.createSteps(element?.steps);
        if (element?.uuid) otherwise.uuid = element?.uuid;
        return otherwise
    }

    static createResequence = (element: any): Resequence => {
        const resequence = element ? new Resequence({...element}) : new Resequence();
        const implicitExpression = CamelApi.getExpressionLanguage(element);
        if (implicitExpression){
            resequence.expression = new Expression({[implicitExpression]: element[implicitExpression]});
            delete (resequence as any)[implicitExpression];
        } else {
            resequence.expression = CamelApi.createExpression(element?.expression);
        }
        resequence.steps = CamelApi.createSteps(element?.steps);
        resequence.uuid = element?.uuid ? element.uuid : resequence.uuid;
        return resequence;
    }

    static createRoutingSlip = (element: any): RoutingSlip => {
        const routingSlip = element ? new RoutingSlip({...element}) : new RoutingSlip();
        const implicitExpression = CamelApi.getExpressionLanguage(element);
        if (implicitExpression){
            routingSlip.expression = new Expression({[implicitExpression]: element[implicitExpression]});
            delete (routingSlip as any)[implicitExpression];
        } else {
            routingSlip.expression = CamelApi.createExpression(element?.expression);
        }
        routingSlip.uuid = element?.uuid ? element.uuid : routingSlip.uuid;
        return routingSlip;
    }

    static createBean = (element: any): Bean => {
        const bean = element ? new Bean({...element}) : new Bean();
        bean.uuid = element?.uuid ? element.uuid : bean.uuid;
        return bean;
    }

    static createRecipientList = (element: any): RecipientList => {
        const recipientList = element ? new RecipientList({...element}) : new RecipientList();
        const implicitExpression = CamelApi.getExpressionLanguage(element);
        if (implicitExpression){
            recipientList.expression = new Expression({[implicitExpression]: element[implicitExpression]});
            delete (recipientList as any)[implicitExpression];
        } else {
            recipientList.expression = CamelApi.createExpression(element?.expression);
        }
        recipientList.uuid = element?.uuid ? element.uuid : recipientList.uuid;
        return recipientList;
    }

    static createKamelet = (element: any): Kamelet => {
        if (element && typeof element === 'string') element = {name: element};
        const kamelet = element ? new Kamelet({...element}) : new Kamelet();
        kamelet.uuid = element?.uuid ? element.uuid : kamelet.uuid;
        return kamelet;
    }

    static createDynamicRouter = (element: any): DynamicRouter => {
        const dynamicRouter = element ? new DynamicRouter({...element}) : new DynamicRouter();
        const implicitExpression = CamelApi.getExpressionLanguage(element);
        if (implicitExpression){
            dynamicRouter.expression = new Expression({[implicitExpression]: element[implicitExpression]});
            delete (dynamicRouter as any)[implicitExpression];
        } else {
            dynamicRouter.expression = CamelApi.createExpression(element?.expression);
        }
        dynamicRouter.uuid = element?.uuid ? element.uuid : dynamicRouter.uuid;
        return dynamicRouter;
    }

    static createRollback = (element: any): Rollback => {
        const rollback = element ? new Rollback({...element}) : new Rollback();
        rollback.uuid = element?.uuid ? element.uuid : rollback.uuid;
        return rollback;
    }

    static createInOut = (element: any): InOut => {
        if (element && typeof element === 'string') element = {uri: element};
        const inOut = element ? new InOut({...element}) : new InOut();
        inOut.uuid = element?.uuid ? element.uuid : inOut.uuid;
        return inOut;
    }

    static createEnrich = (element: any): Enrich => {
        const enrich = element ? new Enrich({...element}) : new Enrich();
        const implicitExpression = CamelApi.getExpressionLanguage(element);
        if (implicitExpression){
            enrich.expression = new Expression({[implicitExpression]: element[implicitExpression]});
            delete (enrich as any)[implicitExpression];
        } else {
            enrich.expression = CamelApi.createExpression(element?.expression);
        }
        enrich.uuid = element?.uuid ? element.uuid : enrich.uuid;
        return enrich;
    }

    static createSplit = (element: any): Split => {
        const split = element ? new Split({...element}) : new Split();
        const implicitExpression = CamelApi.getExpressionLanguage(element);
        if (implicitExpression){
            split.expression = new Expression({[implicitExpression]: element[implicitExpression]});
            delete (split as any)[implicitExpression];
        } else {
            split.expression = CamelApi.createExpression(element?.expression);
        }
        split.steps = CamelApi.createSteps(element?.steps);
        split.uuid = element?.uuid ? element.uuid : split.uuid;
        return split;
    }

    static createWireTap = (element: any): WireTap => {
        const wireTap = element ? new WireTap({...element}) : new WireTap();
        wireTap.body = CamelApi.createExpression(element?.wireTap?.body);
        wireTap.setHeader = element && element?.wireTap ? element?.wireTap?.setHeader.map((x:any) => CamelApi.createSetHeader(x)) :[];
        wireTap.uuid = element?.uuid ? element.uuid : wireTap.uuid;
        return wireTap;
    }

    static createMulticast = (element: any): Multicast => {
        const multicast = element ? new Multicast({...element}) : new Multicast();
        multicast.steps = CamelApi.createSteps(element?.steps);
        multicast.uuid = element?.uuid ? element.uuid : multicast.uuid;
        return multicast;
    }

    static createStop = (element: any): Stop => {
        const stop = element ? new Stop({...element}) : new Stop();
        stop.uuid = element?.uuid ? element.uuid : stop.uuid;
        return stop;
    }

    static createSetBody = (element: any): SetBody => {
        const setBody = element ? new SetBody({...element}) : new SetBody();
        const implicitExpression = CamelApi.getExpressionLanguage(element);
        if (implicitExpression){
            setBody.expression = new Expression({[implicitExpression]: element[implicitExpression]});
            delete (setBody as any)[implicitExpression];
        } else {
            setBody.expression = CamelApi.createExpression(element?.expression);
        }
        setBody.uuid = element?.uuid ? element.uuid : setBody.uuid;
        return setBody;
    }

    static createSort = (element: any): Sort => {
        const sort = element ? new Sort({...element}) : new Sort();
        const implicitExpression = CamelApi.getExpressionLanguage(element);
        if (implicitExpression){
            sort.expression = new Expression({[implicitExpression]: element[implicitExpression]});
            delete (sort as any)[implicitExpression];
        } else {
            sort.expression = CamelApi.createExpression(element?.expression);
        }
        sort.uuid = element?.uuid ? element.uuid : sort.uuid;
        return sort;
    }

    static createInterceptFrom = (element: any): InterceptFrom => {
        const interceptFrom = element ? new InterceptFrom({...element}) : new InterceptFrom();
        interceptFrom.steps = CamelApi.createSteps(element?.steps);
        interceptFrom.uuid = element?.uuid ? element.uuid : interceptFrom.uuid;
        return interceptFrom;
    }

    static createThrowException = (element: any): ThrowException => {
        const throwException = element ? new ThrowException({...element}) : new ThrowException();
        throwException.uuid = element?.uuid ? element.uuid : throwException.uuid;
        return throwException;
    }

    static createTo = (element: any): To => {
        if (typeof element !== 'object') element = {uri: element};
        if (element && typeof element === 'string') element = {uri: element};
        const to = element ? new To({...element}) : new To();
        to.uuid = element?.uuid ? element.uuid : to.uuid;
        return to;
    }

    static createFilter = (element: any): Filter => {
        const filter = element ? new Filter({...element}) : new Filter();
        const implicitExpression = CamelApi.getExpressionLanguage(element);
        if (implicitExpression){
            filter.expression = new Expression({[implicitExpression]: element[implicitExpression]});
            delete (filter as any)[implicitExpression];
        } else {
            filter.expression = CamelApi.createExpression(element?.expression);
        }
        filter.steps = CamelApi.createSteps(element?.steps);
        filter.uuid = element?.uuid ? element.uuid : filter.uuid;
        return filter;
    }

    static createServiceCall = (element: any): ServiceCall => {
        if (element && typeof element === 'string') element = {name: element};
        const serviceCall = element ? new ServiceCall({...element}) : new ServiceCall();
        serviceCall.uuid = element?.uuid ? element.uuid : serviceCall.uuid;
        return serviceCall;
    }

    static createThrottle = (element: any): Throttle => {
        const throttle = element ? new Throttle({...element}) : new Throttle();
        throttle.correlationExpression = CamelApi.createExpression(element?.throttle?.correlationExpression);
        const implicitExpression = CamelApi.getExpressionLanguage(element);
        if (implicitExpression){
            throttle.expression = new Expression({[implicitExpression]: element[implicitExpression]});
            delete (throttle as any)[implicitExpression];
        } else {
            throttle.expression = CamelApi.createExpression(element?.expression);
        }
        throttle.uuid = element?.uuid ? element.uuid : throttle.uuid;
        return throttle;
    }

    static createWhenSkipSendToEndpoint = (element: any): WhenSkipSendToEndpoint => {
        const whenSkipSendToEndpoint = element ? new WhenSkipSendToEndpoint({...element}) : new WhenSkipSendToEndpoint();
        const implicitExpression = CamelApi.getExpressionLanguage(element);
        if (implicitExpression){
            whenSkipSendToEndpoint.expression = new Expression({[implicitExpression]: element[implicitExpression]});
            delete (whenSkipSendToEndpoint as any)[implicitExpression];
        } else {
            whenSkipSendToEndpoint.expression = CamelApi.createExpression(element?.expression);
        }
        whenSkipSendToEndpoint.steps = CamelApi.createSteps(element?.steps);
        whenSkipSendToEndpoint.uuid = element?.uuid ? element.uuid : whenSkipSendToEndpoint.uuid;
        return whenSkipSendToEndpoint;
    }

    static createRemoveProperties = (element: any): RemoveProperties => {
        if (element && typeof element === 'string') element = {pattern: element};
        const removeProperties = element ? new RemoveProperties({...element}) : new RemoveProperties();
        removeProperties.uuid = element?.uuid ? element.uuid : removeProperties.uuid;
        return removeProperties;
    }

    static createSetHeader = (element: any): SetHeader => {
        const setHeader = element ? new SetHeader({...element}) : new SetHeader();
        const implicitExpression = CamelApi.getExpressionLanguage(element);
        if (implicitExpression){
            setHeader.expression = new Expression({[implicitExpression]: element[implicitExpression]});
            delete (setHeader as any)[implicitExpression];
        } else {
            setHeader.expression = CamelApi.createExpression(element?.expression);
        }
        setHeader.uuid = element?.uuid ? element.uuid : setHeader.uuid;
        return setHeader;
    }

    static createChoice = (element: any): Choice => {
        const choiceStep = element ? new Choice({...element}) : new Choice();
        if (element?.otherwise !== undefined){
            choiceStep.otherwise =  CamelApi.createOtherwise(element?.otherwise);
        }
        choiceStep.when = element && element?.when ? element?.when.map((x:any) => CamelApi.createWhen(x)) :[]
        choiceStep.uuid = element?.uuid ? element.uuid : choiceStep.uuid
        return choiceStep
    }

    static createAggregate = (element: any): Aggregate => {
        const aggregate = element ? new Aggregate({...element}) : new Aggregate();
        aggregate.completionPredicate = CamelApi.createExpression(element?.aggregate?.completionPredicate);
        aggregate.completionSizeExpression = CamelApi.createExpression(element?.aggregate?.completionSizeExpression);
        aggregate.completionTimeoutExpression = CamelApi.createExpression(element?.aggregate?.completionTimeoutExpression);
        aggregate.correlationExpression = CamelApi.createExpression(element?.aggregate?.correlationExpression);
        aggregate.steps = CamelApi.createSteps(element?.steps);
        aggregate.uuid = element?.uuid ? element.uuid : aggregate.uuid;
        return aggregate;
    }

    static createRemoveProperty = (element: any): RemoveProperty => {
        const removeProperty = element ? new RemoveProperty({...element}) : new RemoveProperty();
        removeProperty.uuid = element?.uuid ? element.uuid : removeProperty.uuid;
        return removeProperty;
    }

    static createRemoveHeader = (element: any): RemoveHeader => {
        if (element && typeof element === 'string') element = {name: element};
        const removeHeader = element ? new RemoveHeader({...element}) : new RemoveHeader();
        removeHeader.uuid = element?.uuid ? element.uuid : removeHeader.uuid;
        return removeHeader;
    }

    static createScript = (element: any): Script => {
        const script = element ? new Script({...element}) : new Script();
        const implicitExpression = CamelApi.getExpressionLanguage(element);
        if (implicitExpression){
            script.expression = new Expression({[implicitExpression]: element[implicitExpression]});
            delete (script as any)[implicitExpression];
        } else {
            script.expression = CamelApi.createExpression(element?.expression);
        }
        script.uuid = element?.uuid ? element.uuid : script.uuid;
        return script;
    }

    static createDoTry = (element: any): DoTry => {
        const doTry = element ? new DoTry({...element}) : new DoTry();
        doTry.doCatch = element && element?.doTry ? element?.doTry?.doCatch.map((x:any) => CamelApi.createDoCatch(x)) :[];
        doTry.doFinally = CamelApi.createDoFinally(element?.doTry?.doFinally);
        doTry.steps = CamelApi.createSteps(element?.steps);
        doTry.uuid = element?.uuid ? element.uuid : doTry.uuid;
        return doTry;
    }

    static createSetExchangePattern = (element: any): SetExchangePattern => {
        if (element && typeof element === 'string') element = {pattern: element};
        const setExchangePattern = element ? new SetExchangePattern({...element}) : new SetExchangePattern();
        setExchangePattern.uuid = element?.uuid ? element.uuid : setExchangePattern.uuid;
        return setExchangePattern;
    }

    static createTransacted = (element: any): Transacted => {
        const transacted = element ? new Transacted({...element}) : new Transacted();
        transacted.steps = CamelApi.createSteps(element?.steps);
        transacted.uuid = element?.uuid ? element.uuid : transacted.uuid;
        return transacted;
    }

    static createPipeline = (element: any): Pipeline => {
        const pipeline = element ? new Pipeline({...element}) : new Pipeline();
        pipeline.steps = CamelApi.createSteps(element?.steps);
        pipeline.uuid = element?.uuid ? element.uuid : pipeline.uuid;
        return pipeline;
    }

    static createUnmarshal = (element: any): Unmarshal => {
        const unmarshal = element ? new Unmarshal({...element}) : new Unmarshal();
        if (element.any23 !== undefined) unmarshal.any23 = new dataFormat.Any23DataFormat(element.any23);
        if (element.asn1 !== undefined) unmarshal.asn1 = new dataFormat.ASN1DataFormat(element.asn1);
        if (element.avro !== undefined) unmarshal.avro = new dataFormat.AvroDataFormat(element.avro);
        if (element.barcode !== undefined) unmarshal.barcode = new dataFormat.BarcodeDataFormat(element.barcode);
        if (element.base64 !== undefined) unmarshal.base64 = new dataFormat.Base64DataFormat(element.base64);
        if (element.beanio !== undefined) unmarshal.beanio = new dataFormat.BeanioDataFormat(element.beanio);
        if (element.bindy !== undefined) unmarshal.bindy = new dataFormat.BindyDataFormat(element.bindy);
        if (element.cbor !== undefined) unmarshal.cbor = new dataFormat.CBORDataFormat(element.cbor);
        if (element.crypto !== undefined) unmarshal.crypto = new dataFormat.CryptoDataFormat(element.crypto);
        if (element.csv !== undefined) unmarshal.csv = new dataFormat.CsvDataFormat(element.csv);
        if (element.custom !== undefined) unmarshal.custom = new dataFormat.CustomDataFormat(element.custom);
        if (element.fhirJson !== undefined) unmarshal.fhirJson = new dataFormat.FhirJsonDataFormat(element.fhirJson);
        if (element.fhirXml !== undefined) unmarshal.fhirXml = new dataFormat.FhirXmlDataFormat(element.fhirXml);
        if (element.flatpack !== undefined) unmarshal.flatpack = new dataFormat.FlatpackDataFormat(element.flatpack);
        if (element.grok !== undefined) unmarshal.grok = new dataFormat.GrokDataFormat(element.grok);
        if (element.gzip !== undefined) unmarshal.gzip = new dataFormat.GzipDataFormat(element.gzip);
        if (element.hl7 !== undefined) unmarshal.hl7 = new dataFormat.HL7DataFormat(element.hl7);
        if (element.ical !== undefined) unmarshal.ical = new dataFormat.IcalDataFormat(element.ical);
        if (element.jacksonxml !== undefined) unmarshal.jacksonxml = new dataFormat.JacksonXMLDataFormat(element.jacksonxml);
        if (element.jaxb !== undefined) unmarshal.jaxb = new dataFormat.JaxbDataFormat(element.jaxb);
        if (element.json !== undefined) unmarshal.json = new dataFormat.JsonDataFormat(element.json);
        if (element.jsonApi !== undefined) unmarshal.jsonApi = new dataFormat.JsonApiDataFormat(element.jsonApi);
        if (element.lzf !== undefined) unmarshal.lzf = new dataFormat.LZFDataFormat(element.lzf);
        if (element.mimeMultipart !== undefined) unmarshal.mimeMultipart = new dataFormat.MimeMultipartDataFormat(element.mimeMultipart);
        if (element.pgp !== undefined) unmarshal.pgp = new dataFormat.PGPDataFormat(element.pgp);
        if (element.protobuf !== undefined) unmarshal.protobuf = new dataFormat.ProtobufDataFormat(element.protobuf);
        if (element.rss !== undefined) unmarshal.rss = new dataFormat.RssDataFormat(element.rss);
        if (element.secureXml !== undefined) unmarshal.secureXml = new dataFormat.XMLSecurityDataFormat(element.secureXml);
        if (element.soapjaxb !== undefined) unmarshal.soapjaxb = new dataFormat.SoapJaxbDataFormat(element.soapjaxb);
        if (element.syslog !== undefined) unmarshal.syslog = new dataFormat.SyslogDataFormat(element.syslog);
        if (element.tarfile !== undefined) unmarshal.tarfile = new dataFormat.TarFileDataFormat(element.tarfile);
        if (element.thrift !== undefined) unmarshal.thrift = new dataFormat.ThriftDataFormat(element.thrift);
        if (element.tidyMarkup !== undefined) unmarshal.tidyMarkup = new dataFormat.TidyMarkupDataFormat(element.tidyMarkup);
        if (element.univocityCsv !== undefined) unmarshal.univocityCsv = new dataFormat.UniVocityCsvDataFormat(element.univocityCsv);
        if (element.univocityFixed !== undefined) unmarshal.univocityFixed = new dataFormat.UniVocityFixedWidthDataFormat(element.univocityFixed);
        if (element.univocityTsv !== undefined) unmarshal.univocityTsv = new dataFormat.UniVocityTsvDataFormat(element.univocityTsv);
        if (element.xmlrpc !== undefined) unmarshal.xmlrpc = new dataFormat.XmlRpcDataFormat(element.xmlrpc);
        if (element.xstream !== undefined) unmarshal.xstream = new dataFormat.XStreamDataFormat(element.xstream);
        if (element.yaml !== undefined) unmarshal.yaml = new dataFormat.YAMLDataFormat(element.yaml);
        if (element.zip !== undefined) unmarshal.zip = new dataFormat.ZipDeflaterDataFormat(element.zip);
        if (element.zipfile !== undefined) unmarshal.zipfile = new dataFormat.ZipFileDataFormat(element.zipfile);
        unmarshal.uuid = element?.uuid ? element.uuid : unmarshal.uuid;
        return unmarshal;
    }

    static createSteps = (elements: any[] | undefined): CamelElement[] => {
        const result: CamelElement[] = []
        if (elements !== undefined){
            elements.forEach(e => {
                result.push(CamelApi.createStep(CamelUtil.camelizeName(e.dslName, '-', true), e));
            })
        }
        return result
    }

    static addStep = (steps: CamelElement[], step: CamelElement, parentId: string, position?: number): CamelElement[] => {
        const result: CamelElement[] = [];
        steps.forEach(el => {
            switch (el.dslName) {
                case 'policy':
                    const policyChildren = (el as Policy).steps || [];
                    if (el.uuid === parentId) position !== undefined ? policyChildren.splice(position, 0, step) : policyChildren.push(step);
                    else (el as Policy).steps = CamelApi.addStep(policyChildren, step, parentId, position);
                    break;
                case 'choice':
                    const choiceChildren = (el as Choice).when || [];
                    if (el.uuid === parentId && step.dslName === 'when') {
                        choiceChildren.push(step as When);
                        (el as Choice).when = choiceChildren;
                    }  else if (el.uuid === parentId && step.dslName === 'otherwise' && !(el as Choice).otherwise) {
                        (el as Choice).otherwise = step;
                    } else {
                        (el as Choice).when = CamelApi.addStep(choiceChildren, step, parentId, position) as When[];
                        const otherwise = (el as Choice).otherwise;
                        if (otherwise?.uuid === parentId){
                            otherwise.steps = otherwise.steps ? [...otherwise.steps] : [];
                            otherwise.steps.push(step);
                            (el as Choice).otherwise = otherwise
                        } else if (otherwise && otherwise.steps && otherwise.steps.length > 0){
                            otherwise.steps = CamelApi.addStep(otherwise.steps, step, parentId, position);
                            (el as Choice).otherwise = otherwise;
                        }
                    }
                    break;
                case 'otherwise':
                    const otherwiseChildren = (el as Otherwise).steps || [];
                    if (el.uuid === parentId) position !== undefined ? otherwiseChildren.splice(position, 0, step) : otherwiseChildren.push(step);
                    else (el as Otherwise).steps = CamelApi.addStep(otherwiseChildren, step, parentId, position);
                    break;
                case 'from':
                    const fromChildren = (el as From).steps || [];
                    if (el.uuid === parentId) position !== undefined ? fromChildren.splice(position, 0, step) : fromChildren.push(step);
                    else (el as From).steps = CamelApi.addStep(fromChildren, step, parentId, position);
                    break;
                case 'onCompletion':
                    const onCompletionChildren = (el as OnCompletion).steps || [];
                    if (el.uuid === parentId) position !== undefined ? onCompletionChildren.splice(position, 0, step) : onCompletionChildren.push(step);
                    else (el as OnCompletion).steps = CamelApi.addStep(onCompletionChildren, step, parentId, position);
                    break;
                case 'split':
                    const splitChildren = (el as Split).steps || [];
                    if (el.uuid === parentId) position !== undefined ? splitChildren.splice(position, 0, step) : splitChildren.push(step);
                    else (el as Split).steps = CamelApi.addStep(splitChildren, step, parentId, position);
                    break;
                case 'transacted':
                    const transactedChildren = (el as Transacted).steps || [];
                    if (el.uuid === parentId) position !== undefined ? transactedChildren.splice(position, 0, step) : transactedChildren.push(step);
                    else (el as Transacted).steps = CamelApi.addStep(transactedChildren, step, parentId, position);
                    break;
                case 'interceptFrom':
                    const interceptFromChildren = (el as InterceptFrom).steps || [];
                    if (el.uuid === parentId) position !== undefined ? interceptFromChildren.splice(position, 0, step) : interceptFromChildren.push(step);
                    else (el as InterceptFrom).steps = CamelApi.addStep(interceptFromChildren, step, parentId, position);
                    break;
                case 'doCatch':
                    const doCatchChildren = (el as DoCatch).steps || [];
                    if (el.uuid === parentId) position !== undefined ? doCatchChildren.splice(position, 0, step) : doCatchChildren.push(step);
                    else (el as DoCatch).steps = CamelApi.addStep(doCatchChildren, step, parentId, position);
                    break;
                case 'circuitBreaker':
                    const circuitBreakerChildren = (el as CircuitBreaker).steps || [];
                    if (el.uuid === parentId) position !== undefined ? circuitBreakerChildren.splice(position, 0, step) : circuitBreakerChildren.push(step);
                    else (el as CircuitBreaker).steps = CamelApi.addStep(circuitBreakerChildren, step, parentId, position);
                    break;
                case 'intercept':
                    const interceptChildren = (el as Intercept).steps || [];
                    if (el.uuid === parentId) position !== undefined ? interceptChildren.splice(position, 0, step) : interceptChildren.push(step);
                    else (el as Intercept).steps = CamelApi.addStep(interceptChildren, step, parentId, position);
                    break;
                case 'onFallback':
                    const onFallbackChildren = (el as OnFallback).steps || [];
                    if (el.uuid === parentId) position !== undefined ? onFallbackChildren.splice(position, 0, step) : onFallbackChildren.push(step);
                    else (el as OnFallback).steps = CamelApi.addStep(onFallbackChildren, step, parentId, position);
                    break;
                case 'multicast':
                    const multicastChildren = (el as Multicast).steps || [];
                    if (el.uuid === parentId) position !== undefined ? multicastChildren.splice(position, 0, step) : multicastChildren.push(step);
                    else (el as Multicast).steps = CamelApi.addStep(multicastChildren, step, parentId, position);
                    break;
                case 'loadBalance':
                    const loadBalanceChildren = (el as LoadBalance).steps || [];
                    if (el.uuid === parentId) position !== undefined ? loadBalanceChildren.splice(position, 0, step) : loadBalanceChildren.push(step);
                    else (el as LoadBalance).steps = CamelApi.addStep(loadBalanceChildren, step, parentId, position);
                    break;
                case 'whenSkipSendToEndpoint':
                    const whenSkipSendToEndpointChildren = (el as WhenSkipSendToEndpoint).steps || [];
                    if (el.uuid === parentId) position !== undefined ? whenSkipSendToEndpointChildren.splice(position, 0, step) : whenSkipSendToEndpointChildren.push(step);
                    else (el as WhenSkipSendToEndpoint).steps = CamelApi.addStep(whenSkipSendToEndpointChildren, step, parentId, position);
                    break;
                case 'loop':
                    const loopChildren = (el as Loop).steps || [];
                    if (el.uuid === parentId) position !== undefined ? loopChildren.splice(position, 0, step) : loopChildren.push(step);
                    else (el as Loop).steps = CamelApi.addStep(loopChildren, step, parentId, position);
                    break;
                case 'interceptSendToEndpoint':
                    const interceptSendToEndpointChildren = (el as InterceptSendToEndpoint).steps || [];
                    if (el.uuid === parentId) position !== undefined ? interceptSendToEndpointChildren.splice(position, 0, step) : interceptSendToEndpointChildren.push(step);
                    else (el as InterceptSendToEndpoint).steps = CamelApi.addStep(interceptSendToEndpointChildren, step, parentId, position);
                    break;
                case 'doTry':
                    const doTryChildren = (el as DoTry).steps || [];
                    if (el.uuid === parentId) position !== undefined ? doTryChildren.splice(position, 0, step) : doTryChildren.push(step);
                    else (el as DoTry).steps = CamelApi.addStep(doTryChildren, step, parentId, position);
                    break;
                case 'resequence':
                    const resequenceChildren = (el as Resequence).steps || [];
                    if (el.uuid === parentId) position !== undefined ? resequenceChildren.splice(position, 0, step) : resequenceChildren.push(step);
                    else (el as Resequence).steps = CamelApi.addStep(resequenceChildren, step, parentId, position);
                    break;
                case 'pipeline':
                    const pipelineChildren = (el as Pipeline).steps || [];
                    if (el.uuid === parentId) position !== undefined ? pipelineChildren.splice(position, 0, step) : pipelineChildren.push(step);
                    else (el as Pipeline).steps = CamelApi.addStep(pipelineChildren, step, parentId, position);
                    break;
                case 'saga':
                    const sagaChildren = (el as Saga).steps || [];
                    if (el.uuid === parentId) position !== undefined ? sagaChildren.splice(position, 0, step) : sagaChildren.push(step);
                    else (el as Saga).steps = CamelApi.addStep(sagaChildren, step, parentId, position);
                    break;
                case 'when':
                    const whenChildren = (el as When).steps || [];
                    if (el.uuid === parentId) position !== undefined ? whenChildren.splice(position, 0, step) : whenChildren.push(step);
                    else (el as When).steps = CamelApi.addStep(whenChildren, step, parentId, position);
                    break;
                case 'doFinally':
                    const doFinallyChildren = (el as DoFinally).steps || [];
                    if (el.uuid === parentId) position !== undefined ? doFinallyChildren.splice(position, 0, step) : doFinallyChildren.push(step);
                    else (el as DoFinally).steps = CamelApi.addStep(doFinallyChildren, step, parentId, position);
                    break;
                case 'filter':
                    const filterChildren = (el as Filter).steps || [];
                    if (el.uuid === parentId) position !== undefined ? filterChildren.splice(position, 0, step) : filterChildren.push(step);
                    else (el as Filter).steps = CamelApi.addStep(filterChildren, step, parentId, position);
                    break;
                case 'aggregate':
                    const aggregateChildren = (el as Aggregate).steps || [];
                    if (el.uuid === parentId) position !== undefined ? aggregateChildren.splice(position, 0, step) : aggregateChildren.push(step);
                    else (el as Aggregate).steps = CamelApi.addStep(aggregateChildren, step, parentId, position);
                    break;
                case 'idempotentConsumer':
                    const idempotentConsumerChildren = (el as IdempotentConsumer).steps || [];
                    if (el.uuid === parentId) position !== undefined ? idempotentConsumerChildren.splice(position, 0, step) : idempotentConsumerChildren.push(step);
                    else (el as IdempotentConsumer).steps = CamelApi.addStep(idempotentConsumerChildren, step, parentId, position);
                    break;
            }
            result.push(el);
        })
        return result;
    }

    static deleteStep = (steps: CamelElement[] | undefined, uuidToDelete: string): CamelElement[] => {
        const result: CamelElement[] = []
        if (steps !== undefined){
            steps.forEach(step => {
                if (step.uuid !== uuidToDelete){
                    switch (step.dslName){
                        case 'policy': (step as Policy).steps = CamelApi.deleteStep((step as Policy).steps, uuidToDelete); break;
                        case 'choice':
                            const otherwise = (step as Choice).otherwise;
                            if (otherwise && otherwise.uuid === uuidToDelete) {
                                (step as Choice).otherwise = undefined;
                            } else if (otherwise && otherwise.uuid !== uuidToDelete) {
                                otherwise.steps = CamelApi.deleteStep(otherwise.steps, uuidToDelete);
                                (step as Choice).otherwise = otherwise;
                            }
                            (step as Choice).when = CamelApi.deleteWhen((step as Choice).when, uuidToDelete);
                            break;
                        case 'otherwise': (step as Otherwise).steps = CamelApi.deleteStep((step as Otherwise).steps, uuidToDelete); break;
                        case 'from': (step as From).steps = CamelApi.deleteStep((step as From).steps, uuidToDelete); break;
                        case 'onCompletion': (step as OnCompletion).steps = CamelApi.deleteStep((step as OnCompletion).steps, uuidToDelete); break;
                        case 'split': (step as Split).steps = CamelApi.deleteStep((step as Split).steps, uuidToDelete); break;
                        case 'transacted': (step as Transacted).steps = CamelApi.deleteStep((step as Transacted).steps, uuidToDelete); break;
                        case 'interceptFrom': (step as InterceptFrom).steps = CamelApi.deleteStep((step as InterceptFrom).steps, uuidToDelete); break;
                        case 'doCatch': (step as DoCatch).steps = CamelApi.deleteStep((step as DoCatch).steps, uuidToDelete); break;
                        case 'circuitBreaker': (step as CircuitBreaker).steps = CamelApi.deleteStep((step as CircuitBreaker).steps, uuidToDelete); break;
                        case 'intercept': (step as Intercept).steps = CamelApi.deleteStep((step as Intercept).steps, uuidToDelete); break;
                        case 'onFallback': (step as OnFallback).steps = CamelApi.deleteStep((step as OnFallback).steps, uuidToDelete); break;
                        case 'multicast': (step as Multicast).steps = CamelApi.deleteStep((step as Multicast).steps, uuidToDelete); break;
                        case 'loadBalance': (step as LoadBalance).steps = CamelApi.deleteStep((step as LoadBalance).steps, uuidToDelete); break;
                        case 'whenSkipSendToEndpoint': (step as WhenSkipSendToEndpoint).steps = CamelApi.deleteStep((step as WhenSkipSendToEndpoint).steps, uuidToDelete); break;
                        case 'loop': (step as Loop).steps = CamelApi.deleteStep((step as Loop).steps, uuidToDelete); break;
                        case 'interceptSendToEndpoint': (step as InterceptSendToEndpoint).steps = CamelApi.deleteStep((step as InterceptSendToEndpoint).steps, uuidToDelete); break;
                        case 'doTry': (step as DoTry).steps = CamelApi.deleteStep((step as DoTry).steps, uuidToDelete); break;
                        case 'resequence': (step as Resequence).steps = CamelApi.deleteStep((step as Resequence).steps, uuidToDelete); break;
                        case 'pipeline': (step as Pipeline).steps = CamelApi.deleteStep((step as Pipeline).steps, uuidToDelete); break;
                        case 'saga': (step as Saga).steps = CamelApi.deleteStep((step as Saga).steps, uuidToDelete); break;
                        case 'when': (step as When).steps = CamelApi.deleteStep((step as When).steps, uuidToDelete); break;
                        case 'doFinally': (step as DoFinally).steps = CamelApi.deleteStep((step as DoFinally).steps, uuidToDelete); break;
                        case 'filter': (step as Filter).steps = CamelApi.deleteStep((step as Filter).steps, uuidToDelete); break;
                        case 'aggregate': (step as Aggregate).steps = CamelApi.deleteStep((step as Aggregate).steps, uuidToDelete); break;
                        case 'idempotentConsumer': (step as IdempotentConsumer).steps = CamelApi.deleteStep((step as IdempotentConsumer).steps, uuidToDelete); break;
                    }
                    result.push(step);
                }
            })
        }
        return result
    }

    static deleteWhen = (whens: When[] | undefined, uuidToDelete: string): When[] => {
        const result: When[] = []
        if (whens !== undefined){
            whens.forEach(when => {
                if (when.uuid !== uuidToDelete) {
                    when.steps = CamelApi.deleteStep(when.steps, uuidToDelete);
                    result.push(when);
                }
            })
        }
        return result
    }

    static findStep = (steps: CamelElement[] | undefined, uuid: string, parentUuid?: string, result?: CamelElementMeta): CamelElementMeta => {
        if (result?.step !== undefined) return result;
        if (result === undefined) result = new CamelElementMeta(undefined, parentUuid, undefined, []);
        if (steps !== undefined){
            for (let index = 0, step; step = steps[index]; index++) {
                if (step.uuid !== uuid) {
                    switch (step.dslName) {
                        case 'policy':
                            result = CamelApi.findStep((step as Policy).steps, uuid, step.uuid, result);
                            if (result?.pathUuids !== undefined && result?.pathUuids.length > 0) result.pathUuids.push(step.uuid);
                            break;
                        case 'choice':
                            const o = (step as Choice).otherwise;
                            const w = (step as Choice).when;
                            const s: CamelElement[] = [];
                            if (o) s.push(o);
                            if (w) s.push(...w);
                            result = CamelApi.findStep(s, uuid, step.uuid, result);
                            if (result?.pathUuids !== undefined && result?.pathUuids.length > 0) result.pathUuids.push(step.uuid);
                            break;
                        case 'otherwise':
                            result = CamelApi.findStep((step as Otherwise).steps, uuid, step.uuid, result);
                            if (result?.pathUuids !== undefined && result?.pathUuids.length > 0) result.pathUuids.push(step.uuid);
                            break;
                        case 'from':
                            result = CamelApi.findStep((step as From).steps, uuid, step.uuid, result);
                            if (result?.pathUuids !== undefined && result?.pathUuids.length > 0) result.pathUuids.push(step.uuid);
                            break;
                        case 'onCompletion':
                            result = CamelApi.findStep((step as OnCompletion).steps, uuid, step.uuid, result);
                            if (result?.pathUuids !== undefined && result?.pathUuids.length > 0) result.pathUuids.push(step.uuid);
                            break;
                        case 'split':
                            result = CamelApi.findStep((step as Split).steps, uuid, step.uuid, result);
                            if (result?.pathUuids !== undefined && result?.pathUuids.length > 0) result.pathUuids.push(step.uuid);
                            break;
                        case 'transacted':
                            result = CamelApi.findStep((step as Transacted).steps, uuid, step.uuid, result);
                            if (result?.pathUuids !== undefined && result?.pathUuids.length > 0) result.pathUuids.push(step.uuid);
                            break;
                        case 'interceptFrom':
                            result = CamelApi.findStep((step as InterceptFrom).steps, uuid, step.uuid, result);
                            if (result?.pathUuids !== undefined && result?.pathUuids.length > 0) result.pathUuids.push(step.uuid);
                            break;
                        case 'doCatch':
                            result = CamelApi.findStep((step as DoCatch).steps, uuid, step.uuid, result);
                            if (result?.pathUuids !== undefined && result?.pathUuids.length > 0) result.pathUuids.push(step.uuid);
                            break;
                        case 'circuitBreaker':
                            result = CamelApi.findStep((step as CircuitBreaker).steps, uuid, step.uuid, result);
                            if (result?.pathUuids !== undefined && result?.pathUuids.length > 0) result.pathUuids.push(step.uuid);
                            break;
                        case 'intercept':
                            result = CamelApi.findStep((step as Intercept).steps, uuid, step.uuid, result);
                            if (result?.pathUuids !== undefined && result?.pathUuids.length > 0) result.pathUuids.push(step.uuid);
                            break;
                        case 'onFallback':
                            result = CamelApi.findStep((step as OnFallback).steps, uuid, step.uuid, result);
                            if (result?.pathUuids !== undefined && result?.pathUuids.length > 0) result.pathUuids.push(step.uuid);
                            break;
                        case 'multicast':
                            result = CamelApi.findStep((step as Multicast).steps, uuid, step.uuid, result);
                            if (result?.pathUuids !== undefined && result?.pathUuids.length > 0) result.pathUuids.push(step.uuid);
                            break;
                        case 'loadBalance':
                            result = CamelApi.findStep((step as LoadBalance).steps, uuid, step.uuid, result);
                            if (result?.pathUuids !== undefined && result?.pathUuids.length > 0) result.pathUuids.push(step.uuid);
                            break;
                        case 'whenSkipSendToEndpoint':
                            result = CamelApi.findStep((step as WhenSkipSendToEndpoint).steps, uuid, step.uuid, result);
                            if (result?.pathUuids !== undefined && result?.pathUuids.length > 0) result.pathUuids.push(step.uuid);
                            break;
                        case 'loop':
                            result = CamelApi.findStep((step as Loop).steps, uuid, step.uuid, result);
                            if (result?.pathUuids !== undefined && result?.pathUuids.length > 0) result.pathUuids.push(step.uuid);
                            break;
                        case 'interceptSendToEndpoint':
                            result = CamelApi.findStep((step as InterceptSendToEndpoint).steps, uuid, step.uuid, result);
                            if (result?.pathUuids !== undefined && result?.pathUuids.length > 0) result.pathUuids.push(step.uuid);
                            break;
                        case 'doTry':
                            result = CamelApi.findStep((step as DoTry).steps, uuid, step.uuid, result);
                            if (result?.pathUuids !== undefined && result?.pathUuids.length > 0) result.pathUuids.push(step.uuid);
                            break;
                        case 'resequence':
                            result = CamelApi.findStep((step as Resequence).steps, uuid, step.uuid, result);
                            if (result?.pathUuids !== undefined && result?.pathUuids.length > 0) result.pathUuids.push(step.uuid);
                            break;
                        case 'pipeline':
                            result = CamelApi.findStep((step as Pipeline).steps, uuid, step.uuid, result);
                            if (result?.pathUuids !== undefined && result?.pathUuids.length > 0) result.pathUuids.push(step.uuid);
                            break;
                        case 'saga':
                            result = CamelApi.findStep((step as Saga).steps, uuid, step.uuid, result);
                            if (result?.pathUuids !== undefined && result?.pathUuids.length > 0) result.pathUuids.push(step.uuid);
                            break;
                        case 'when':
                            result = CamelApi.findStep((step as When).steps, uuid, step.uuid, result);
                            if (result?.pathUuids !== undefined && result?.pathUuids.length > 0) result.pathUuids.push(step.uuid);
                            break;
                        case 'doFinally':
                            result = CamelApi.findStep((step as DoFinally).steps, uuid, step.uuid, result);
                            if (result?.pathUuids !== undefined && result?.pathUuids.length > 0) result.pathUuids.push(step.uuid);
                            break;
                        case 'filter':
                            result = CamelApi.findStep((step as Filter).steps, uuid, step.uuid, result);
                            if (result?.pathUuids !== undefined && result?.pathUuids.length > 0) result.pathUuids.push(step.uuid);
                            break;
                        case 'aggregate':
                            result = CamelApi.findStep((step as Aggregate).steps, uuid, step.uuid, result);
                            if (result?.pathUuids !== undefined && result?.pathUuids.length > 0) result.pathUuids.push(step.uuid);
                            break;
                        case 'idempotentConsumer':
                            result = CamelApi.findStep((step as IdempotentConsumer).steps, uuid, step.uuid, result);
                            if (result?.pathUuids !== undefined && result?.pathUuids.length > 0) result.pathUuids.push(step.uuid);
                            break;
                    }
                } else {
                    const paths: string[] = result?.pathUuids ? result?.pathUuids : [];
                    paths.push(step.uuid);
                    result = new  CamelElementMeta(step, parentUuid, index, paths);
                    break;
                }
            }
        }
        const paths: string[] = result?.pathUuids ? result?.pathUuids : [];
        return new CamelElementMeta(result?.step, result?.parentUuid, result?.position, result?.pathUuids);
    }

    static getExpressionLanguage = (init?: Partial<Expression>): string | undefined => {
        if (init?.constant) return 'constant'
        if (init?.csimple) return 'csimple'
        if (init?.datasonnet) return 'datasonnet'
        if (init?.exchangeProperty) return 'exchangeProperty'
        if (init?.groovy) return 'groovy'
        if (init?.header) return 'header'
        if (init?.hl7terser) return 'hl7terser'
        if (init?.joor) return 'joor'
        if (init?.jsonpath) return 'jsonpath'
        if (init?.method) return 'method'
        if (init?.mvel) return 'mvel'
        if (init?.ognl) return 'ognl'
        if (init?.ref) return 'ref'
        if (init?.simple) return 'simple'
        if (init?.spel) return 'spel'
        if (init?.tokenize) return 'tokenize'
        if (init?.xpath) return 'xpath'
        if (init?.xquery) return 'xquery'
        if (init?.xtokenize) return 'xtokenize'
        return undefined;
    }
}

