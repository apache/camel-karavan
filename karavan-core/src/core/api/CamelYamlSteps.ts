/**
 * Generated by karavan build tools - do NOT edit this file!
 */
import {
    CamelElement, 
    From, 
    Expression, 
    Policy,
    SetProperty,
    Saga,
    ToD,
    Threads,
    InterceptSendToEndpoint,
    Log,
    Loop,
    Delay,
    Sample,
    DoFinally,
    LoadBalance,
    Validate,
    Transform,
    RemoveHeaders,
    IdempotentConsumer,
    Intercept,
    When, 
    Process,
    OnFallback,
    Marshal,
    OnCompletion,
    ClaimCheck,
    DoCatch,
    InOnly,
    ConvertBodyTo,
    CircuitBreaker,
    PollEnrich,
    Otherwise, 
    Resequence,
    RoutingSlip,
    Bean,
    RecipientList,
    Kamelet,
    DynamicRouter,
    Rollback,
    InOut,
    Enrich,
    Split,
    WireTap,
    Multicast,
    Stop,
    SetBody,
    Sort,
    InterceptFrom,
    ThrowException,
    To,
    Filter,
    ServiceCall,
    Throttle,
    WhenSkipSendToEndpoint,
    RemoveProperties,
    SetHeader,
    Choice,
    Aggregate,
    RemoveProperty,
    RemoveHeader,
    Script,
    DoTry,
    SetExchangePattern,
    Transacted,
    Pipeline,
    Unmarshal,
} from '../model/CamelModel' 
import * as dataFormat from '../model/CamelDataFormat'; 
import {CamelUtil} from "./CamelUtil";  

export class CamelYamlStep { 

    static readStep = (name: string, body: any, clone: boolean = false): CamelElement => {
       const newBody = CamelUtil.camelizeBody(name, body, clone);
       switch (name){
            case 'from': return CamelYamlStep.readFrom(newBody);
            case 'expression': return CamelYamlStep.readExpression(newBody);
            case 'policy': return CamelYamlStep.readPolicy(newBody);
            case 'setProperty': return CamelYamlStep.readSetProperty(newBody);
            case 'saga': return CamelYamlStep.readSaga(newBody);
            case 'toD': return CamelYamlStep.readToD(newBody);
            case 'threads': return CamelYamlStep.readThreads(newBody);
            case 'interceptSendToEndpoint': return CamelYamlStep.readInterceptSendToEndpoint(newBody);
            case 'log': return CamelYamlStep.readLog(newBody);
            case 'loop': return CamelYamlStep.readLoop(newBody);
            case 'delay': return CamelYamlStep.readDelay(newBody);
            case 'sample': return CamelYamlStep.readSample(newBody);
            case 'doFinally': return CamelYamlStep.readDoFinally(newBody);
            case 'loadBalance': return CamelYamlStep.readLoadBalance(newBody);
            case 'validate': return CamelYamlStep.readValidate(newBody);
            case 'transform': return CamelYamlStep.readTransform(newBody);
            case 'removeHeaders': return CamelYamlStep.readRemoveHeaders(newBody);
            case 'idempotentConsumer': return CamelYamlStep.readIdempotentConsumer(newBody);
            case 'intercept': return CamelYamlStep.readIntercept(newBody);
            case 'when': return CamelYamlStep.readWhen(newBody);
            case 'process': return CamelYamlStep.readProcess(newBody);
            case 'onFallback': return CamelYamlStep.readOnFallback(newBody);
            case 'marshal': return CamelYamlStep.readMarshal(newBody);
            case 'onCompletion': return CamelYamlStep.readOnCompletion(newBody);
            case 'claimCheck': return CamelYamlStep.readClaimCheck(newBody);
            case 'doCatch': return CamelYamlStep.readDoCatch(newBody);
            case 'inOnly': return CamelYamlStep.readInOnly(newBody);
            case 'convertBodyTo': return CamelYamlStep.readConvertBodyTo(newBody);
            case 'circuitBreaker': return CamelYamlStep.readCircuitBreaker(newBody);
            case 'pollEnrich': return CamelYamlStep.readPollEnrich(newBody);
            case 'otherwise': return CamelYamlStep.readOtherwise(newBody);
            case 'resequence': return CamelYamlStep.readResequence(newBody);
            case 'routingSlip': return CamelYamlStep.readRoutingSlip(newBody);
            case 'bean': return CamelYamlStep.readBean(newBody);
            case 'recipientList': return CamelYamlStep.readRecipientList(newBody);
            case 'kamelet': return CamelYamlStep.readKamelet(newBody);
            case 'dynamicRouter': return CamelYamlStep.readDynamicRouter(newBody);
            case 'rollback': return CamelYamlStep.readRollback(newBody);
            case 'inOut': return CamelYamlStep.readInOut(newBody);
            case 'enrich': return CamelYamlStep.readEnrich(newBody);
            case 'split': return CamelYamlStep.readSplit(newBody);
            case 'wireTap': return CamelYamlStep.readWireTap(newBody);
            case 'multicast': return CamelYamlStep.readMulticast(newBody);
            case 'stop': return CamelYamlStep.readStop(newBody);
            case 'setBody': return CamelYamlStep.readSetBody(newBody);
            case 'sort': return CamelYamlStep.readSort(newBody);
            case 'interceptFrom': return CamelYamlStep.readInterceptFrom(newBody);
            case 'throwException': return CamelYamlStep.readThrowException(newBody);
            case 'to': return CamelYamlStep.readTo(newBody);
            case 'filter': return CamelYamlStep.readFilter(newBody);
            case 'serviceCall': return CamelYamlStep.readServiceCall(newBody);
            case 'throttle': return CamelYamlStep.readThrottle(newBody);
            case 'whenSkipSendToEndpoint': return CamelYamlStep.readWhenSkipSendToEndpoint(newBody);
            case 'removeProperties': return CamelYamlStep.readRemoveProperties(newBody);
            case 'setHeader': return CamelYamlStep.readSetHeader(newBody);
            case 'choice': return CamelYamlStep.readChoice(newBody);
            case 'aggregate': return CamelYamlStep.readAggregate(newBody);
            case 'removeProperty': return CamelYamlStep.readRemoveProperty(newBody);
            case 'removeHeader': return CamelYamlStep.readRemoveHeader(newBody);
            case 'script': return CamelYamlStep.readScript(newBody);
            case 'doTry': return CamelYamlStep.readDoTry(newBody);
            case 'setExchangePattern': return CamelYamlStep.readSetExchangePattern(newBody);
            case 'transacted': return CamelYamlStep.readTransacted(newBody);
            case 'pipeline': return CamelYamlStep.readPipeline(newBody);
            case 'unmarshal': return CamelYamlStep.readUnmarshal(newBody);
            default: return new CamelElement('');
        }
    }
    static readExpression = (element: any): Expression => {
        return new Expression({...element})
    }
    static readFrom = (element: any): From => {
        if (element && element.from && typeof element.from === 'string') element.from = {uri: element.from};
        const from = element ? new From({...element.from}) : new From();
        from.steps = CamelYamlStep.readSteps(element?.from?.steps);
        from.uuid = element?.uuid ? element.uuid : from.uuid;
        return from;
    }

    static readPolicy = (element: any): Policy => {
        const policy = element ? new Policy({...element.policy}) : new Policy();
        policy.steps = CamelYamlStep.readSteps(element?.policy?.steps);
        policy.uuid = element?.uuid ? element.uuid : policy.uuid;
        return policy;
    }

    static readSetProperty = (element: any): SetProperty => {
        const setProperty = element ? new SetProperty({...element.setProperty}) : new SetProperty();
        const implicitExpression = CamelYamlStep.readExpressionLanguage(element.setProperty);
        if (implicitExpression){
            setProperty.expression = new Expression({[implicitExpression]: element.setProperty[implicitExpression]});
            delete (setProperty as any)[implicitExpression];
        } else {
            setProperty.expression = CamelYamlStep.readExpression(element?.setProperty?.expression);
        }
        setProperty.uuid = element?.uuid ? element.uuid : setProperty.uuid;
        return setProperty;
    }

    static readSaga = (element: any): Saga => {
        const saga = element ? new Saga({...element.saga}) : new Saga();
        saga.steps = CamelYamlStep.readSteps(element?.saga?.steps);
        saga.uuid = element?.uuid ? element.uuid : saga.uuid;
        return saga;
    }

    static readToD = (element: any): ToD => {
        if (element && element.toD && typeof element.toD === 'string') element.toD = {uri: element.toD};
        const toD = element ? new ToD({...element.toD}) : new ToD();
        toD.uuid = element?.uuid ? element.uuid : toD.uuid;
        return toD;
    }

    static readThreads = (element: any): Threads => {
        const threads = element ? new Threads({...element.threads}) : new Threads();
        threads.uuid = element?.uuid ? element.uuid : threads.uuid;
        return threads;
    }

    static readInterceptSendToEndpoint = (element: any): InterceptSendToEndpoint => {
        if (element && element.interceptSendToEndpoint && typeof element.interceptSendToEndpoint === 'string') element.interceptSendToEndpoint = {uri: element.interceptSendToEndpoint};
        const interceptSendToEndpoint = element ? new InterceptSendToEndpoint({...element.interceptSendToEndpoint}) : new InterceptSendToEndpoint();
        interceptSendToEndpoint.steps = CamelYamlStep.readSteps(element?.interceptSendToEndpoint?.steps);
        interceptSendToEndpoint.uuid = element?.uuid ? element.uuid : interceptSendToEndpoint.uuid;
        return interceptSendToEndpoint;
    }

    static readLog = (element: any): Log => {
        if (element && element.log && typeof element.log === 'string') element.log = {message: element.log};
        const log = element ? new Log({...element.log}) : new Log();
        log.uuid = element?.uuid ? element.uuid : log.uuid;
        return log;
    }

    static readLoop = (element: any): Loop => {
        const loop = element ? new Loop({...element.loop}) : new Loop();
        const implicitExpression = CamelYamlStep.readExpressionLanguage(element.loop);
        if (implicitExpression){
            loop.expression = new Expression({[implicitExpression]: element.loop[implicitExpression]});
            delete (loop as any)[implicitExpression];
        } else {
            loop.expression = CamelYamlStep.readExpression(element?.loop?.expression);
        }
        loop.steps = CamelYamlStep.readSteps(element?.loop?.steps);
        loop.uuid = element?.uuid ? element.uuid : loop.uuid;
        return loop;
    }

    static readDelay = (element: any): Delay => {
        const delay = element ? new Delay({...element.delay}) : new Delay();
        const implicitExpression = CamelYamlStep.readExpressionLanguage(element.delay);
        if (implicitExpression){
            delay.expression = new Expression({[implicitExpression]: element.delay[implicitExpression]});
            delete (delay as any)[implicitExpression];
        } else {
            delay.expression = CamelYamlStep.readExpression(element?.delay?.expression);
        }
        delay.uuid = element?.uuid ? element.uuid : delay.uuid;
        return delay;
    }

    static readSample = (element: any): Sample => {
        const sample = element ? new Sample({...element.sample}) : new Sample();
        sample.uuid = element?.uuid ? element.uuid : sample.uuid;
        return sample;
    }

    static readDoFinally = (element: any): DoFinally => {
        const doFinally = element ? new DoFinally({...element.doFinally}) : new DoFinally();
        doFinally.steps = CamelYamlStep.readSteps(element?.doFinally?.steps);
        doFinally.uuid = element?.uuid ? element.uuid : doFinally.uuid;
        return doFinally;
    }

    static readLoadBalance = (element: any): LoadBalance => {
        const loadBalance = element ? new LoadBalance({...element.loadBalance}) : new LoadBalance();
        loadBalance.steps = CamelYamlStep.readSteps(element?.loadBalance?.steps);
        loadBalance.uuid = element?.uuid ? element.uuid : loadBalance.uuid;
        return loadBalance;
    }

    static readValidate = (element: any): Validate => {
        const validate = element ? new Validate({...element.validate}) : new Validate();
        const implicitExpression = CamelYamlStep.readExpressionLanguage(element.validate);
        if (implicitExpression){
            validate.expression = new Expression({[implicitExpression]: element.validate[implicitExpression]});
            delete (validate as any)[implicitExpression];
        } else {
            validate.expression = CamelYamlStep.readExpression(element?.validate?.expression);
        }
        validate.uuid = element?.uuid ? element.uuid : validate.uuid;
        return validate;
    }

    static readTransform = (element: any): Transform => {
        const transform = element ? new Transform({...element.transform}) : new Transform();
        const implicitExpression = CamelYamlStep.readExpressionLanguage(element.transform);
        if (implicitExpression){
            transform.expression = new Expression({[implicitExpression]: element.transform[implicitExpression]});
            delete (transform as any)[implicitExpression];
        } else {
            transform.expression = CamelYamlStep.readExpression(element?.transform?.expression);
        }
        transform.uuid = element?.uuid ? element.uuid : transform.uuid;
        return transform;
    }

    static readRemoveHeaders = (element: any): RemoveHeaders => {
        if (element && element.removeHeaders && typeof element.removeHeaders === 'string') element.removeHeaders = {pattern: element.removeHeaders};
        const removeHeaders = element ? new RemoveHeaders({...element.removeHeaders}) : new RemoveHeaders();
        removeHeaders.uuid = element?.uuid ? element.uuid : removeHeaders.uuid;
        return removeHeaders;
    }

    static readIdempotentConsumer = (element: any): IdempotentConsumer => {
        const idempotentConsumer = element ? new IdempotentConsumer({...element.idempotentConsumer}) : new IdempotentConsumer();
        const implicitExpression = CamelYamlStep.readExpressionLanguage(element.idempotentConsumer);
        if (implicitExpression){
            idempotentConsumer.expression = new Expression({[implicitExpression]: element.idempotentConsumer[implicitExpression]});
            delete (idempotentConsumer as any)[implicitExpression];
        } else {
            idempotentConsumer.expression = CamelYamlStep.readExpression(element?.idempotentConsumer?.expression);
        }
        idempotentConsumer.steps = CamelYamlStep.readSteps(element?.idempotentConsumer?.steps);
        idempotentConsumer.uuid = element?.uuid ? element.uuid : idempotentConsumer.uuid;
        return idempotentConsumer;
    }

    static readIntercept = (element: any): Intercept => {
        const intercept = element ? new Intercept({...element.intercept}) : new Intercept();
        intercept.steps = CamelYamlStep.readSteps(element?.intercept?.steps);
        intercept.uuid = element?.uuid ? element.uuid : intercept.uuid;
        return intercept;
    }

    static readWhen = (element: any): When => {
        const when = element ? new When({...element}) : new When()
        when.expression = CamelYamlStep.readExpression(element?.expression)
        when.steps = CamelYamlStep.readSteps(element?.steps)
        when.uuid = element?.uuid ? element.uuid : when.uuid
        return when
    }

    static readProcess = (element: any): Process => {
        const process = element ? new Process({...element.process}) : new Process();
        process.uuid = element?.uuid ? element.uuid : process.uuid;
        return process;
    }

    static readOnFallback = (element: any): OnFallback => {
        const onFallback = element ? new OnFallback({...element.onFallback}) : new OnFallback();
        onFallback.steps = CamelYamlStep.readSteps(element?.onFallback?.steps);
        onFallback.uuid = element?.uuid ? element.uuid : onFallback.uuid;
        return onFallback;
    }

    static readMarshal = (element: any): Marshal => {
        const marshal = element ? new Marshal({...element.marshal}) : new Marshal();
        if (element.marshal?.any23 !== undefined) marshal.any23 = new dataFormat.Any23DataFormat(element.marshal.any23);
        if (element.marshal?.asn1 !== undefined) marshal.asn1 = new dataFormat.ASN1DataFormat(element.marshal.asn1);
        if (element.marshal?.avro !== undefined) marshal.avro = new dataFormat.AvroDataFormat(element.marshal.avro);
        if (element.marshal?.barcode !== undefined) marshal.barcode = new dataFormat.BarcodeDataFormat(element.marshal.barcode);
        if (element.marshal?.base64 !== undefined) marshal.base64 = new dataFormat.Base64DataFormat(element.marshal.base64);
        if (element.marshal?.beanio !== undefined) marshal.beanio = new dataFormat.BeanioDataFormat(element.marshal.beanio);
        if (element.marshal?.bindy !== undefined) marshal.bindy = new dataFormat.BindyDataFormat(element.marshal.bindy);
        if (element.marshal?.cbor !== undefined) marshal.cbor = new dataFormat.CBORDataFormat(element.marshal.cbor);
        if (element.marshal?.crypto !== undefined) marshal.crypto = new dataFormat.CryptoDataFormat(element.marshal.crypto);
        if (element.marshal?.csv !== undefined) marshal.csv = new dataFormat.CsvDataFormat(element.marshal.csv);
        if (element.marshal?.custom !== undefined) marshal.custom = new dataFormat.CustomDataFormat(element.marshal.custom);
        if (element.marshal?.fhirJson !== undefined) marshal.fhirJson = new dataFormat.FhirJsonDataFormat(element.marshal.fhirJson);
        if (element.marshal?.fhirXml !== undefined) marshal.fhirXml = new dataFormat.FhirXmlDataFormat(element.marshal.fhirXml);
        if (element.marshal?.flatpack !== undefined) marshal.flatpack = new dataFormat.FlatpackDataFormat(element.marshal.flatpack);
        if (element.marshal?.grok !== undefined) marshal.grok = new dataFormat.GrokDataFormat(element.marshal.grok);
        if (element.marshal?.gzip !== undefined) marshal.gzip = new dataFormat.GzipDataFormat(element.marshal.gzip);
        if (element.marshal?.hl7 !== undefined) marshal.hl7 = new dataFormat.HL7DataFormat(element.marshal.hl7);
        if (element.marshal?.ical !== undefined) marshal.ical = new dataFormat.IcalDataFormat(element.marshal.ical);
        if (element.marshal?.jacksonxml !== undefined) marshal.jacksonxml = new dataFormat.JacksonXMLDataFormat(element.marshal.jacksonxml);
        if (element.marshal?.jaxb !== undefined) marshal.jaxb = new dataFormat.JaxbDataFormat(element.marshal.jaxb);
        if (element.marshal?.json !== undefined) marshal.json = new dataFormat.JsonDataFormat(element.marshal.json);
        if (element.marshal?.jsonApi !== undefined) marshal.jsonApi = new dataFormat.JsonApiDataFormat(element.marshal.jsonApi);
        if (element.marshal?.lzf !== undefined) marshal.lzf = new dataFormat.LZFDataFormat(element.marshal.lzf);
        if (element.marshal?.mimeMultipart !== undefined) marshal.mimeMultipart = new dataFormat.MimeMultipartDataFormat(element.marshal.mimeMultipart);
        if (element.marshal?.pgp !== undefined) marshal.pgp = new dataFormat.PGPDataFormat(element.marshal.pgp);
        if (element.marshal?.protobuf !== undefined) marshal.protobuf = new dataFormat.ProtobufDataFormat(element.marshal.protobuf);
        if (element.marshal?.rss !== undefined) marshal.rss = new dataFormat.RssDataFormat(element.marshal.rss);
        if (element.marshal?.secureXml !== undefined) marshal.secureXml = new dataFormat.XMLSecurityDataFormat(element.marshal.secureXml);
        if (element.marshal?.soapjaxb !== undefined) marshal.soapjaxb = new dataFormat.SoapJaxbDataFormat(element.marshal.soapjaxb);
        if (element.marshal?.syslog !== undefined) marshal.syslog = new dataFormat.SyslogDataFormat(element.marshal.syslog);
        if (element.marshal?.tarfile !== undefined) marshal.tarfile = new dataFormat.TarFileDataFormat(element.marshal.tarfile);
        if (element.marshal?.thrift !== undefined) marshal.thrift = new dataFormat.ThriftDataFormat(element.marshal.thrift);
        if (element.marshal?.tidyMarkup !== undefined) marshal.tidyMarkup = new dataFormat.TidyMarkupDataFormat(element.marshal.tidyMarkup);
        if (element.marshal?.univocityCsv !== undefined) marshal.univocityCsv = new dataFormat.UniVocityCsvDataFormat(element.marshal.univocityCsv);
        if (element.marshal?.univocityFixed !== undefined) marshal.univocityFixed = new dataFormat.UniVocityFixedWidthDataFormat(element.marshal.univocityFixed);
        if (element.marshal?.univocityTsv !== undefined) marshal.univocityTsv = new dataFormat.UniVocityTsvDataFormat(element.marshal.univocityTsv);
        if (element.marshal?.xmlrpc !== undefined) marshal.xmlrpc = new dataFormat.XmlRpcDataFormat(element.marshal.xmlrpc);
        if (element.marshal?.xstream !== undefined) marshal.xstream = new dataFormat.XStreamDataFormat(element.marshal.xstream);
        if (element.marshal?.yaml !== undefined) marshal.yaml = new dataFormat.YAMLDataFormat(element.marshal.yaml);
        if (element.marshal?.zip !== undefined) marshal.zip = new dataFormat.ZipDeflaterDataFormat(element.marshal.zip);
        if (element.marshal?.zipfile !== undefined) marshal.zipfile = new dataFormat.ZipFileDataFormat(element.marshal.zipfile);
        marshal.uuid = element?.uuid ? element.uuid : marshal.uuid;
        return marshal;
    }

    static readOnCompletion = (element: any): OnCompletion => {
        const onCompletion = element ? new OnCompletion({...element.onCompletion}) : new OnCompletion();
        onCompletion.onWhen = CamelYamlStep.readWhen(element?.onCompletion?.onWhen);
        onCompletion.steps = CamelYamlStep.readSteps(element?.onCompletion?.steps);
        onCompletion.uuid = element?.uuid ? element.uuid : onCompletion.uuid;
        return onCompletion;
    }

    static readClaimCheck = (element: any): ClaimCheck => {
        const claimCheck = element ? new ClaimCheck({...element.claimCheck}) : new ClaimCheck();
        claimCheck.uuid = element?.uuid ? element.uuid : claimCheck.uuid;
        return claimCheck;
    }

    static readDoCatch = (element: any): DoCatch => {
        const doCatch = element ? new DoCatch({...element.doCatch}) : new DoCatch();
        doCatch.onWhen = CamelYamlStep.readWhen(element?.doCatch?.onWhen);
        doCatch.steps = CamelYamlStep.readSteps(element?.doCatch?.steps);
        doCatch.uuid = element?.uuid ? element.uuid : doCatch.uuid;
        return doCatch;
    }

    static readInOnly = (element: any): InOnly => {
        if (element && element.inOnly && typeof element.inOnly === 'string') element.inOnly = {uri: element.inOnly};
        const inOnly = element ? new InOnly({...element.inOnly}) : new InOnly();
        inOnly.uuid = element?.uuid ? element.uuid : inOnly.uuid;
        return inOnly;
    }

    static readConvertBodyTo = (element: any): ConvertBodyTo => {
        if (element && element.convertBodyTo && typeof element.convertBodyTo === 'string') element.convertBodyTo = {type: element.convertBodyTo};
        const convertBodyTo = element ? new ConvertBodyTo({...element.convertBodyTo}) : new ConvertBodyTo();
        convertBodyTo.uuid = element?.uuid ? element.uuid : convertBodyTo.uuid;
        return convertBodyTo;
    }

    static readCircuitBreaker = (element: any): CircuitBreaker => {
        const circuitBreaker = element ? new CircuitBreaker({...element.circuitBreaker}) : new CircuitBreaker();
        circuitBreaker.onFallback = CamelYamlStep.readOnFallback(element?.circuitBreaker?.onFallback);
        circuitBreaker.steps = CamelYamlStep.readSteps(element?.circuitBreaker?.steps);
        circuitBreaker.uuid = element?.uuid ? element.uuid : circuitBreaker.uuid;
        return circuitBreaker;
    }

    static readPollEnrich = (element: any): PollEnrich => {
        const pollEnrich = element ? new PollEnrich({...element.pollEnrich}) : new PollEnrich();
        const implicitExpression = CamelYamlStep.readExpressionLanguage(element.pollEnrich);
        if (implicitExpression){
            pollEnrich.expression = new Expression({[implicitExpression]: element.pollEnrich[implicitExpression]});
            delete (pollEnrich as any)[implicitExpression];
        } else {
            pollEnrich.expression = CamelYamlStep.readExpression(element?.pollEnrich?.expression);
        }
        pollEnrich.uuid = element?.uuid ? element.uuid : pollEnrich.uuid;
        return pollEnrich;
    }

    static readOtherwise = (element: any): Otherwise => {
        const otherwise = element ? new Otherwise({...element}) : new Otherwise();
        otherwise.steps = CamelYamlStep.readSteps(element?.steps);
        if (element?.uuid) otherwise.uuid = element?.uuid;
        return otherwise
    }

    static readResequence = (element: any): Resequence => {
        const resequence = element ? new Resequence({...element.resequence}) : new Resequence();
        const implicitExpression = CamelYamlStep.readExpressionLanguage(element.resequence);
        if (implicitExpression){
            resequence.expression = new Expression({[implicitExpression]: element.resequence[implicitExpression]});
            delete (resequence as any)[implicitExpression];
        } else {
            resequence.expression = CamelYamlStep.readExpression(element?.resequence?.expression);
        }
        resequence.steps = CamelYamlStep.readSteps(element?.resequence?.steps);
        resequence.uuid = element?.uuid ? element.uuid : resequence.uuid;
        return resequence;
    }

    static readRoutingSlip = (element: any): RoutingSlip => {
        const routingSlip = element ? new RoutingSlip({...element.routingSlip}) : new RoutingSlip();
        const implicitExpression = CamelYamlStep.readExpressionLanguage(element.routingSlip);
        if (implicitExpression){
            routingSlip.expression = new Expression({[implicitExpression]: element.routingSlip[implicitExpression]});
            delete (routingSlip as any)[implicitExpression];
        } else {
            routingSlip.expression = CamelYamlStep.readExpression(element?.routingSlip?.expression);
        }
        routingSlip.uuid = element?.uuid ? element.uuid : routingSlip.uuid;
        return routingSlip;
    }

    static readBean = (element: any): Bean => {
        const bean = element ? new Bean({...element.bean}) : new Bean();
        bean.uuid = element?.uuid ? element.uuid : bean.uuid;
        return bean;
    }

    static readRecipientList = (element: any): RecipientList => {
        const recipientList = element ? new RecipientList({...element.recipientList}) : new RecipientList();
        const implicitExpression = CamelYamlStep.readExpressionLanguage(element.recipientList);
        if (implicitExpression){
            recipientList.expression = new Expression({[implicitExpression]: element.recipientList[implicitExpression]});
            delete (recipientList as any)[implicitExpression];
        } else {
            recipientList.expression = CamelYamlStep.readExpression(element?.recipientList?.expression);
        }
        recipientList.uuid = element?.uuid ? element.uuid : recipientList.uuid;
        return recipientList;
    }

    static readKamelet = (element: any): Kamelet => {
        if (element && element.kamelet && typeof element.kamelet === 'string') element.kamelet = {name: element.kamelet};
        const kamelet = element ? new Kamelet({...element.kamelet}) : new Kamelet();
        kamelet.uuid = element?.uuid ? element.uuid : kamelet.uuid;
        return kamelet;
    }

    static readDynamicRouter = (element: any): DynamicRouter => {
        const dynamicRouter = element ? new DynamicRouter({...element.dynamicRouter}) : new DynamicRouter();
        const implicitExpression = CamelYamlStep.readExpressionLanguage(element.dynamicRouter);
        if (implicitExpression){
            dynamicRouter.expression = new Expression({[implicitExpression]: element.dynamicRouter[implicitExpression]});
            delete (dynamicRouter as any)[implicitExpression];
        } else {
            dynamicRouter.expression = CamelYamlStep.readExpression(element?.dynamicRouter?.expression);
        }
        dynamicRouter.uuid = element?.uuid ? element.uuid : dynamicRouter.uuid;
        return dynamicRouter;
    }

    static readRollback = (element: any): Rollback => {
        const rollback = element ? new Rollback({...element.rollback}) : new Rollback();
        rollback.uuid = element?.uuid ? element.uuid : rollback.uuid;
        return rollback;
    }

    static readInOut = (element: any): InOut => {
        if (element && element.inOut && typeof element.inOut === 'string') element.inOut = {uri: element.inOut};
        const inOut = element ? new InOut({...element.inOut}) : new InOut();
        inOut.uuid = element?.uuid ? element.uuid : inOut.uuid;
        return inOut;
    }

    static readEnrich = (element: any): Enrich => {
        const enrich = element ? new Enrich({...element.enrich}) : new Enrich();
        const implicitExpression = CamelYamlStep.readExpressionLanguage(element.enrich);
        if (implicitExpression){
            enrich.expression = new Expression({[implicitExpression]: element.enrich[implicitExpression]});
            delete (enrich as any)[implicitExpression];
        } else {
            enrich.expression = CamelYamlStep.readExpression(element?.enrich?.expression);
        }
        enrich.uuid = element?.uuid ? element.uuid : enrich.uuid;
        return enrich;
    }

    static readSplit = (element: any): Split => {
        const split = element ? new Split({...element.split}) : new Split();
        const implicitExpression = CamelYamlStep.readExpressionLanguage(element.split);
        if (implicitExpression){
            split.expression = new Expression({[implicitExpression]: element.split[implicitExpression]});
            delete (split as any)[implicitExpression];
        } else {
            split.expression = CamelYamlStep.readExpression(element?.split?.expression);
        }
        split.steps = CamelYamlStep.readSteps(element?.split?.steps);
        split.uuid = element?.uuid ? element.uuid : split.uuid;
        return split;
    }

    static readWireTap = (element: any): WireTap => {
        const wireTap = element ? new WireTap({...element.wireTap}) : new WireTap();
        wireTap.body = CamelYamlStep.readExpression(element?.wireTap?.body);
        wireTap.setHeader = element && element?.wireTap ? element?.wireTap?.setHeader.map((x:any) => CamelYamlStep.readSetHeader(x)) :[];
        wireTap.uuid = element?.uuid ? element.uuid : wireTap.uuid;
        return wireTap;
    }

    static readMulticast = (element: any): Multicast => {
        const multicast = element ? new Multicast({...element.multicast}) : new Multicast();
        multicast.steps = CamelYamlStep.readSteps(element?.multicast?.steps);
        multicast.uuid = element?.uuid ? element.uuid : multicast.uuid;
        return multicast;
    }

    static readStop = (element: any): Stop => {
        const stop = element ? new Stop({...element.stop}) : new Stop();
        stop.uuid = element?.uuid ? element.uuid : stop.uuid;
        return stop;
    }

    static readSetBody = (element: any): SetBody => {
        const setBody = element ? new SetBody({...element.setBody}) : new SetBody();
        const implicitExpression = CamelYamlStep.readExpressionLanguage(element.setBody);
        if (implicitExpression){
            setBody.expression = new Expression({[implicitExpression]: element.setBody[implicitExpression]});
            delete (setBody as any)[implicitExpression];
        } else {
            setBody.expression = CamelYamlStep.readExpression(element?.setBody?.expression);
        }
        setBody.uuid = element?.uuid ? element.uuid : setBody.uuid;
        return setBody;
    }

    static readSort = (element: any): Sort => {
        const sort = element ? new Sort({...element.sort}) : new Sort();
        const implicitExpression = CamelYamlStep.readExpressionLanguage(element.sort);
        if (implicitExpression){
            sort.expression = new Expression({[implicitExpression]: element.sort[implicitExpression]});
            delete (sort as any)[implicitExpression];
        } else {
            sort.expression = CamelYamlStep.readExpression(element?.sort?.expression);
        }
        sort.uuid = element?.uuid ? element.uuid : sort.uuid;
        return sort;
    }

    static readInterceptFrom = (element: any): InterceptFrom => {
        const interceptFrom = element ? new InterceptFrom({...element.interceptFrom}) : new InterceptFrom();
        interceptFrom.steps = CamelYamlStep.readSteps(element?.interceptFrom?.steps);
        interceptFrom.uuid = element?.uuid ? element.uuid : interceptFrom.uuid;
        return interceptFrom;
    }

    static readThrowException = (element: any): ThrowException => {
        const throwException = element ? new ThrowException({...element.throwException}) : new ThrowException();
        throwException.uuid = element?.uuid ? element.uuid : throwException.uuid;
        return throwException;
    }

    static readTo = (element: any): To => {
        if (typeof element.to !== 'object') element.to = {uri: element.to};
        if (element && element.to && typeof element.to === 'string') element.to = {uri: element.to};
        const to = element ? new To({...element.to}) : new To();
        to.uuid = element?.uuid ? element.uuid : to.uuid;
        return to;
    }

    static readFilter = (element: any): Filter => {
        const filter = element ? new Filter({...element.filter}) : new Filter();
        const implicitExpression = CamelYamlStep.readExpressionLanguage(element.filter);
        if (implicitExpression){
            filter.expression = new Expression({[implicitExpression]: element.filter[implicitExpression]});
            delete (filter as any)[implicitExpression];
        } else {
            filter.expression = CamelYamlStep.readExpression(element?.filter?.expression);
        }
        filter.steps = CamelYamlStep.readSteps(element?.filter?.steps);
        filter.uuid = element?.uuid ? element.uuid : filter.uuid;
        return filter;
    }

    static readServiceCall = (element: any): ServiceCall => {
        if (element && element.serviceCall && typeof element.serviceCall === 'string') element.serviceCall = {name: element.serviceCall};
        const serviceCall = element ? new ServiceCall({...element.serviceCall}) : new ServiceCall();
        serviceCall.uuid = element?.uuid ? element.uuid : serviceCall.uuid;
        return serviceCall;
    }

    static readThrottle = (element: any): Throttle => {
        const throttle = element ? new Throttle({...element.throttle}) : new Throttle();
        throttle.correlationExpression = CamelYamlStep.readExpression(element?.throttle?.correlationExpression);
        const implicitExpression = CamelYamlStep.readExpressionLanguage(element.throttle);
        if (implicitExpression){
            throttle.expression = new Expression({[implicitExpression]: element.throttle[implicitExpression]});
            delete (throttle as any)[implicitExpression];
        } else {
            throttle.expression = CamelYamlStep.readExpression(element?.throttle?.expression);
        }
        throttle.uuid = element?.uuid ? element.uuid : throttle.uuid;
        return throttle;
    }

    static readWhenSkipSendToEndpoint = (element: any): WhenSkipSendToEndpoint => {
        const whenSkipSendToEndpoint = element ? new WhenSkipSendToEndpoint({...element.whenSkipSendToEndpoint}) : new WhenSkipSendToEndpoint();
        const implicitExpression = CamelYamlStep.readExpressionLanguage(element.whenSkipSendToEndpoint);
        if (implicitExpression){
            whenSkipSendToEndpoint.expression = new Expression({[implicitExpression]: element.whenSkipSendToEndpoint[implicitExpression]});
            delete (whenSkipSendToEndpoint as any)[implicitExpression];
        } else {
            whenSkipSendToEndpoint.expression = CamelYamlStep.readExpression(element?.whenSkipSendToEndpoint?.expression);
        }
        whenSkipSendToEndpoint.steps = CamelYamlStep.readSteps(element?.whenSkipSendToEndpoint?.steps);
        whenSkipSendToEndpoint.uuid = element?.uuid ? element.uuid : whenSkipSendToEndpoint.uuid;
        return whenSkipSendToEndpoint;
    }

    static readRemoveProperties = (element: any): RemoveProperties => {
        if (element && element.removeProperties && typeof element.removeProperties === 'string') element.removeProperties = {pattern: element.removeProperties};
        const removeProperties = element ? new RemoveProperties({...element.removeProperties}) : new RemoveProperties();
        removeProperties.uuid = element?.uuid ? element.uuid : removeProperties.uuid;
        return removeProperties;
    }

    static readSetHeader = (element: any): SetHeader => {
        const setHeader = element ? new SetHeader({...element.setHeader}) : new SetHeader();
        const implicitExpression = CamelYamlStep.readExpressionLanguage(element.setHeader);
        if (implicitExpression){
            setHeader.expression = new Expression({[implicitExpression]: element.setHeader[implicitExpression]});
            delete (setHeader as any)[implicitExpression];
        } else {
            setHeader.expression = CamelYamlStep.readExpression(element?.setHeader?.expression);
        }
        setHeader.uuid = element?.uuid ? element.uuid : setHeader.uuid;
        return setHeader;
    }

    static readChoice = (element: any): Choice => {
        const choiceStep = element ? new Choice({...element.choice}) : new Choice();
        if (element?.choice?.otherwise !== undefined){
            choiceStep.otherwise =  CamelYamlStep.readOtherwise(element?.choice?.otherwise);
        }
        choiceStep.when = element && element?.choice && element?.choice?.when ? element?.choice?.when.map((x:any) => CamelYamlStep.readWhen(x)) :[]
        choiceStep.uuid = element?.uuid ? element.uuid : choiceStep.uuid
        return choiceStep
    }

    static readAggregate = (element: any): Aggregate => {
        const aggregate = element ? new Aggregate({...element.aggregate}) : new Aggregate();
        aggregate.completionPredicate = CamelYamlStep.readExpression(element?.aggregate?.completionPredicate);
        aggregate.completionSizeExpression = CamelYamlStep.readExpression(element?.aggregate?.completionSizeExpression);
        aggregate.completionTimeoutExpression = CamelYamlStep.readExpression(element?.aggregate?.completionTimeoutExpression);
        aggregate.correlationExpression = CamelYamlStep.readExpression(element?.aggregate?.correlationExpression);
        aggregate.steps = CamelYamlStep.readSteps(element?.aggregate?.steps);
        aggregate.uuid = element?.uuid ? element.uuid : aggregate.uuid;
        return aggregate;
    }

    static readRemoveProperty = (element: any): RemoveProperty => {
        if (element && element.removeProperty && typeof element.removeProperty === 'string') element.removeProperty = {propertyName: element.removeProperty};
        const removeProperty = element ? new RemoveProperty({...element.removeProperty}) : new RemoveProperty();
        removeProperty.uuid = element?.uuid ? element.uuid : removeProperty.uuid;
        return removeProperty;
    }

    static readRemoveHeader = (element: any): RemoveHeader => {
        const removeHeader = element ? new RemoveHeader({...element.removeHeader}) : new RemoveHeader();
        removeHeader.uuid = element?.uuid ? element.uuid : removeHeader.uuid;
        return removeHeader;
    }

    static readScript = (element: any): Script => {
        const script = element ? new Script({...element.script}) : new Script();
        const implicitExpression = CamelYamlStep.readExpressionLanguage(element.script);
        if (implicitExpression){
            script.expression = new Expression({[implicitExpression]: element.script[implicitExpression]});
            delete (script as any)[implicitExpression];
        } else {
            script.expression = CamelYamlStep.readExpression(element?.script?.expression);
        }
        script.uuid = element?.uuid ? element.uuid : script.uuid;
        return script;
    }

    static readDoTry = (element: any): DoTry => {
        const doTry = element ? new DoTry({...element.doTry}) : new DoTry();
        doTry.doCatch = element && element?.doTry ? element?.doTry?.doCatch.map((x:any) => CamelYamlStep.readDoCatch(x)) :[];
        doTry.doFinally = CamelYamlStep.readDoFinally(element?.doTry?.doFinally);
        doTry.steps = CamelYamlStep.readSteps(element?.doTry?.steps);
        doTry.uuid = element?.uuid ? element.uuid : doTry.uuid;
        return doTry;
    }

    static readSetExchangePattern = (element: any): SetExchangePattern => {
        if (element && element.setExchangePattern && typeof element.setExchangePattern === 'string') element.setExchangePattern = {pattern: element.setExchangePattern};
        const setExchangePattern = element ? new SetExchangePattern({...element.setExchangePattern}) : new SetExchangePattern();
        setExchangePattern.uuid = element?.uuid ? element.uuid : setExchangePattern.uuid;
        return setExchangePattern;
    }

    static readTransacted = (element: any): Transacted => {
        const transacted = element ? new Transacted({...element.transacted}) : new Transacted();
        transacted.steps = CamelYamlStep.readSteps(element?.transacted?.steps);
        transacted.uuid = element?.uuid ? element.uuid : transacted.uuid;
        return transacted;
    }

    static readPipeline = (element: any): Pipeline => {
        const pipeline = element ? new Pipeline({...element.pipeline}) : new Pipeline();
        pipeline.steps = CamelYamlStep.readSteps(element?.pipeline?.steps);
        pipeline.uuid = element?.uuid ? element.uuid : pipeline.uuid;
        return pipeline;
    }

    static readUnmarshal = (element: any): Unmarshal => {
        const unmarshal = element ? new Unmarshal({...element.unmarshal}) : new Unmarshal();
        if (element.unmarshal?.any23 !== undefined) unmarshal.any23 = new dataFormat.Any23DataFormat(element.unmarshal.any23);
        if (element.unmarshal?.asn1 !== undefined) unmarshal.asn1 = new dataFormat.ASN1DataFormat(element.unmarshal.asn1);
        if (element.unmarshal?.avro !== undefined) unmarshal.avro = new dataFormat.AvroDataFormat(element.unmarshal.avro);
        if (element.unmarshal?.barcode !== undefined) unmarshal.barcode = new dataFormat.BarcodeDataFormat(element.unmarshal.barcode);
        if (element.unmarshal?.base64 !== undefined) unmarshal.base64 = new dataFormat.Base64DataFormat(element.unmarshal.base64);
        if (element.unmarshal?.beanio !== undefined) unmarshal.beanio = new dataFormat.BeanioDataFormat(element.unmarshal.beanio);
        if (element.unmarshal?.bindy !== undefined) unmarshal.bindy = new dataFormat.BindyDataFormat(element.unmarshal.bindy);
        if (element.unmarshal?.cbor !== undefined) unmarshal.cbor = new dataFormat.CBORDataFormat(element.unmarshal.cbor);
        if (element.unmarshal?.crypto !== undefined) unmarshal.crypto = new dataFormat.CryptoDataFormat(element.unmarshal.crypto);
        if (element.unmarshal?.csv !== undefined) unmarshal.csv = new dataFormat.CsvDataFormat(element.unmarshal.csv);
        if (element.unmarshal?.custom !== undefined) unmarshal.custom = new dataFormat.CustomDataFormat(element.unmarshal.custom);
        if (element.unmarshal?.fhirJson !== undefined) unmarshal.fhirJson = new dataFormat.FhirJsonDataFormat(element.unmarshal.fhirJson);
        if (element.unmarshal?.fhirXml !== undefined) unmarshal.fhirXml = new dataFormat.FhirXmlDataFormat(element.unmarshal.fhirXml);
        if (element.unmarshal?.flatpack !== undefined) unmarshal.flatpack = new dataFormat.FlatpackDataFormat(element.unmarshal.flatpack);
        if (element.unmarshal?.grok !== undefined) unmarshal.grok = new dataFormat.GrokDataFormat(element.unmarshal.grok);
        if (element.unmarshal?.gzip !== undefined) unmarshal.gzip = new dataFormat.GzipDataFormat(element.unmarshal.gzip);
        if (element.unmarshal?.hl7 !== undefined) unmarshal.hl7 = new dataFormat.HL7DataFormat(element.unmarshal.hl7);
        if (element.unmarshal?.ical !== undefined) unmarshal.ical = new dataFormat.IcalDataFormat(element.unmarshal.ical);
        if (element.unmarshal?.jacksonxml !== undefined) unmarshal.jacksonxml = new dataFormat.JacksonXMLDataFormat(element.unmarshal.jacksonxml);
        if (element.unmarshal?.jaxb !== undefined) unmarshal.jaxb = new dataFormat.JaxbDataFormat(element.unmarshal.jaxb);
        if (element.unmarshal?.json !== undefined) unmarshal.json = new dataFormat.JsonDataFormat(element.unmarshal.json);
        if (element.unmarshal?.jsonApi !== undefined) unmarshal.jsonApi = new dataFormat.JsonApiDataFormat(element.unmarshal.jsonApi);
        if (element.unmarshal?.lzf !== undefined) unmarshal.lzf = new dataFormat.LZFDataFormat(element.unmarshal.lzf);
        if (element.unmarshal?.mimeMultipart !== undefined) unmarshal.mimeMultipart = new dataFormat.MimeMultipartDataFormat(element.unmarshal.mimeMultipart);
        if (element.unmarshal?.pgp !== undefined) unmarshal.pgp = new dataFormat.PGPDataFormat(element.unmarshal.pgp);
        if (element.unmarshal?.protobuf !== undefined) unmarshal.protobuf = new dataFormat.ProtobufDataFormat(element.unmarshal.protobuf);
        if (element.unmarshal?.rss !== undefined) unmarshal.rss = new dataFormat.RssDataFormat(element.unmarshal.rss);
        if (element.unmarshal?.secureXml !== undefined) unmarshal.secureXml = new dataFormat.XMLSecurityDataFormat(element.unmarshal.secureXml);
        if (element.unmarshal?.soapjaxb !== undefined) unmarshal.soapjaxb = new dataFormat.SoapJaxbDataFormat(element.unmarshal.soapjaxb);
        if (element.unmarshal?.syslog !== undefined) unmarshal.syslog = new dataFormat.SyslogDataFormat(element.unmarshal.syslog);
        if (element.unmarshal?.tarfile !== undefined) unmarshal.tarfile = new dataFormat.TarFileDataFormat(element.unmarshal.tarfile);
        if (element.unmarshal?.thrift !== undefined) unmarshal.thrift = new dataFormat.ThriftDataFormat(element.unmarshal.thrift);
        if (element.unmarshal?.tidyMarkup !== undefined) unmarshal.tidyMarkup = new dataFormat.TidyMarkupDataFormat(element.unmarshal.tidyMarkup);
        if (element.unmarshal?.univocityCsv !== undefined) unmarshal.univocityCsv = new dataFormat.UniVocityCsvDataFormat(element.unmarshal.univocityCsv);
        if (element.unmarshal?.univocityFixed !== undefined) unmarshal.univocityFixed = new dataFormat.UniVocityFixedWidthDataFormat(element.unmarshal.univocityFixed);
        if (element.unmarshal?.univocityTsv !== undefined) unmarshal.univocityTsv = new dataFormat.UniVocityTsvDataFormat(element.unmarshal.univocityTsv);
        if (element.unmarshal?.xmlrpc !== undefined) unmarshal.xmlrpc = new dataFormat.XmlRpcDataFormat(element.unmarshal.xmlrpc);
        if (element.unmarshal?.xstream !== undefined) unmarshal.xstream = new dataFormat.XStreamDataFormat(element.unmarshal.xstream);
        if (element.unmarshal?.yaml !== undefined) unmarshal.yaml = new dataFormat.YAMLDataFormat(element.unmarshal.yaml);
        if (element.unmarshal?.zip !== undefined) unmarshal.zip = new dataFormat.ZipDeflaterDataFormat(element.unmarshal.zip);
        if (element.unmarshal?.zipfile !== undefined) unmarshal.zipfile = new dataFormat.ZipFileDataFormat(element.unmarshal.zipfile);
        unmarshal.uuid = element?.uuid ? element.uuid : unmarshal.uuid;
        return unmarshal;
    }

    static readSteps = (elements: any[] | undefined): CamelElement[] => {
        const result: CamelElement[] = []
        if (elements !== undefined){
            elements.forEach(e => {
                const stepName = Object.keys(e).filter(key => !['uuid', 'dslName'].includes(key))[0];
                result.push(CamelYamlStep.readStep(CamelUtil.camelizeName(stepName, '-', true), e));
            })
        }
        return result
    }

    static readExpressionLanguage = (init?: Partial<Expression>): string | undefined => {
        if (init?.constant) return 'constant'
        if (init?.csimple) return 'csimple'
        if (init?.datasonnet) return 'datasonnet'
        if (init?.exchangeProperty) return 'exchangeProperty'
        if (init?.groovy) return 'groovy'
        if (init?.header) return 'header'
        if (init?.hl7terser) return 'hl7terser'
        if (init?.joor) return 'joor'
        if (init?.jsonpath) return 'jsonpath'
        if (init?.method) return 'method'
        if (init?.mvel) return 'mvel'
        if (init?.ognl) return 'ognl'
        if (init?.ref) return 'ref'
        if (init?.simple) return 'simple'
        if (init?.spel) return 'spel'
        if (init?.tokenize) return 'tokenize'
        if (init?.xpath) return 'xpath'
        if (init?.xquery) return 'xquery'
        if (init?.xtokenize) return 'xtokenize'
        return undefined;
    }
}

